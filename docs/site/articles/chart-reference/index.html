<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Chart Reference</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for citations */
    div.csl-bib-body { }
    div.csl-entry {
      clear: both;
      margin-bottom: 0em;
    }
    .hanging-indent div.csl-entry {
      margin-left:2em;
      text-indent:-2em;
    }
    div.csl-left-margin {
      min-width:2em;
      float:left;
    }
    div.csl-right-inline {
      margin-left:2em;
      padding-left:1em;
    }
    div.csl-indent {
      margin-left: 2em;
    }
    html {
      box-sizing: border-box;
      font-size: 100%;
    }

    *, *:before, *:after {
      box-sizing: inherit;
    }

    body {
      margin: 0;
      padding: 0;
      font-family: Nunito, Arial, sans-serif;
      font-size: 1.1rem;
      line-height: 1.75;
      background: #fff;
      color: #111;

      /* Remove Pandoc's injected width restrictions */
      max-width: none !important;
      padding-left: 0 !important;
      padding-right: 0 !important;
      padding-top: 0 !important;
      padding-bottom: 0 !important;
    }

    .wrapper {
      display: flex;
      justify-content: center;
    }

    #page {
      max-width: 1240px;
      width: 100%;
      padding: 2rem 1rem;
    }

    h1, h2, h3, h4 {
      font-weight: bold;
      margin-top: 2rem;
      margin-bottom: 1rem;
      line-height: 1.4;
    }

    p {
      margin: 1.25rem 0;
    }

    img {
      max-width: 100%;
      height: auto;
      display: block;
      margin: 2rem auto;
    }

    pre {
      background: #f8f8f8;
      padding: 1rem;
      overflow-x: auto;
      border-radius: 6px;
    }

    code {
      font-family: SFMono-Regular, Consolas, monospace;
      background: #f5f5f5;
      padding: 0.2em 0.4em;
      border-radius: 4px;
    }

    blockquote {
      margin: 2rem 0;
      padding-left: 1rem;
      border-left: 4px solid #ddd;
      color: #666;
      font-style: italic;
    }

    .subtitle, .author, .date {
      color: #666;
      font-size: 0.9rem;
      margin-top: 0.5rem;
      text-align: center;
    }

    .doc-layout {
      display: block;
      margin-top: 1rem;
    }

    .doc-content {
      min-width: 0;
    }

    .doc-toc {
      margin: 1rem 0 1.5rem;
    }

    .doc-toc nav#TOC {
      margin: 0;
      padding: 1rem;
      border: 1px solid #e5e7ea;
      background: #fafafa;
      border-radius: 8px;
      overflow-x: auto;
    }

    nav#TOC h2 {
      margin-top: 0;
      margin-bottom: 0.75rem;
      font-size: 1rem;
    }

    nav#TOC ul {
      margin: 0;
      padding-left: 1.1rem;
      line-height: 1.45;
    }

    nav#TOC li {
      margin: 0.22rem 0;
    }

    nav#TOC a {
      color: #1f2937;
      text-decoration: none;
      font-weight: 500;
    }

    nav#TOC a:hover {
      text-decoration: underline;
    }

    figure {
      margin: 2rem auto;
      text-align: center;
    }

    figure img {
      width: 100%;
      height: auto;
      display: block;
      margin: 2rem auto;
    }

    .doc-content img.lightboxable {
      cursor: zoom-in;
      border-radius: 6px;
      box-shadow: 0 0 0 1px rgba(17, 24, 39, 0.08);
      transition: transform 140ms ease, box-shadow 140ms ease;
    }

    .doc-content img.lightboxable:hover {
      transform: translateY(-1px);
      box-shadow: 0 8px 24px rgba(17, 24, 39, 0.18);
    }

    .doc-content img.lightboxable:focus-visible {
      outline: 3px solid #6b7280;
      outline-offset: 2px;
    }

    .doc-content figure {
      position: relative;
    }

    .doc-content figure.has-lightbox::after {
      content: "";
      position: absolute;
      right: 0.75rem;
      top: 0.75rem;
      width: 2rem;
      height: 2rem;
      background-color: rgba(255, 255, 255, 0.92);
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23111827' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='15 3 21 3 21 9'/%3E%3Cpolyline points='9 21 3 21 3 15'/%3E%3Cline x1='21' y1='3' x2='14' y2='10'/%3E%3Cline x1='3' y1='21' x2='10' y2='14'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: center;
      background-size: 1.1rem 1.1rem;
      border: 1px solid rgba(17, 24, 39, 0.2);
      border-radius: 999px;
      pointer-events: none;
    }

    .lightbox-overlay {
      position: fixed;
      inset: 0;
      z-index: 9999;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(10, 10, 10, 0.88);
      padding: 2.5rem 1rem 1rem;
    }

    .lightbox-overlay.is-open {
      display: flex;
    }

    .lightbox-overlay img {
      max-width: min(96vw, 1800px);
      max-height: 88vh;
      width: auto;
      height: auto;
      margin: 0;
      box-shadow: 0 16px 48px rgba(0, 0, 0, 0.5);
      border-radius: 4px;
      background: #fff;
    }

    .lightbox-close {
      position: absolute;
      top: 0.8rem;
      right: 0.8rem;
      border: 1px solid rgba(255, 255, 255, 0.45);
      background: rgba(17, 24, 39, 0.82);
      color: #fff;
      border-radius: 999px;
      width: 2.2rem;
      height: 2.2rem;
      font-size: 1.2rem;
      line-height: 1;
      cursor: pointer;
    }

    .lightbox-close:hover {
      background: rgba(17, 24, 39, 0.95);
    }

    figcaption {
      font-size: 0.9em;
      color: #555;
      margin-top: 0.75rem;
    }

    header#title-block-header {
      text-align: center;
    }

    #presence-link {
      margin: 3rem auto 0;
      padding: 1.25rem 1rem 1.5rem;
      text-align: center;
      font-size: 0.95rem;
      color: #444;
      border-top: 1px solid #e5e7ea;
      background: #f9f9f9;
      border-radius: 8px 8px 0 0;
    }

    #presence-link a {
      text-decoration: none;
      color: #222;
      font-weight: 600;
    }

    #presence-link a:hover {
      text-decoration: underline;
    }

    .site-nav {
      margin: 0 auto 2rem;
      padding: 0.75rem 1rem;
      background: #f6f7f8;
      border: 1px solid #e5e7ea;
      border-radius: 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem 1.25rem;
      justify-content: center;
      font-size: 0.98rem;
    }

    .site-nav a {
      color: #222;
      text-decoration: none;
      font-weight: 600;
      padding: 0.2rem 0.35rem;
    }

    .site-nav a:hover {
      text-decoration: underline;
    }


    @media screen and (min-width: 1024px) {
      body {
        font-size: 1.15rem;
      }

      #page {
        padding: 3rem 2rem;
      }
    }

    @media screen and (min-width: 1120px) {
      .doc-layout.has-toc {
        display: grid;
        grid-template-columns: minmax(240px, 290px) minmax(0, 1fr);
        gap: 2rem;
        align-items: start;
      }

      .doc-layout.has-toc .doc-toc {
        position: sticky;
        top: 1.25rem;
        max-height: calc(100vh - 2.5rem);
        overflow: auto;
        margin: 0;
        padding-right: 0.15rem;
      }

      .doc-layout.has-toc .doc-content {
        min-width: 0;
      }
    }

  </style>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
</head>
<body>
  <div class="wrapper">
    <div id="page">
      <nav class="site-nav" aria-label="Primary">
        <a href="https://samplepath.pcalc.org/index.html">Home</a>
        <a href="https://samplepath.pcalc.org/articles/package-overview/index.html">Package Overview</a>
        <a href="https://samplepath.pcalc.org/articles/theory/index.html">Theory</a>
        <a href="https://samplepath.pcalc.org/articles/cli/index.html">Command Line</a>
        <a href="https://samplepath.pcalc.org/articles/chart-reference/index.html">Chart Reference</a>
        <a href="https://samplepath.pcalc.org/examples/README.html">Examples</a>
      </nav>
                  <header id="title-block-header">
        <h1 class="title"><strong>Chart Reference</strong></h1>

        <p class="author"><p><a href="https://github.com/presence-calculus/samplepath"><em>The
Samplepath Analysis Toolkit</em></a></p></p>

              </header>
                  <div class="header-image">
        <img src="../../articles/chart-reference/chart_reference_small/with-events/core/panels/arrival_departure_indicator_process.png" alt="Header image"/>
      </div>
            <div class="doc-layout has-toc">
                <aside class="doc-toc" aria-label="Contents">
          <nav id="TOC" role="doc-toc">
            <h2 id="toc-title">Contents</h2>
            <ul>
            <li><a href="#sample-path-flow-metrics"
            id="toc-sample-path-flow-metrics">1 Sample Path Flow
            Metrics</a>
            <ul>
            <li><a href="#methodology" id="toc-methodology">1.1
            Methodology</a></li>
            </ul></li>
            <li><a href="#notational-conventions"
            id="toc-notational-conventions">2 Notational Conventions</a>
            <ul>
            <li><a href="#measurements" id="toc-measurements">2.1
            Measurements</a></li>
            <li><a href="#notation" id="toc-notation">2.2
            Notation</a></li>
            <li><a href="#timescales-and-indexes"
            id="toc-timescales-and-indexes">2.3 Timescales and
            Indexes</a></li>
            <li><a href="#event-display" id="toc-event-display">2.4
            Event display</a></li>
            </ul></li>
            <li><a href="#the-presence-invariant"
            id="toc-the-presence-invariant">3 The Presence Invariant</a>
            <ul>
            <li><a href="#chart-01-point-process"
            id="toc-chart-01-point-process">3.1 Point Process - Event
            Stream</a></li>
            <li><a href="#chart-02-arrivals-a"
            id="toc-chart-02-arrivals-a">3.2 A(T) - Cumulative
            Arrivals</a></li>
            <li><a href="#chart-03-departures-d"
            id="toc-chart-03-departures-d">3.3 D(T) - Cumulative
            Departures</a></li>
            <li><a href="#chart-04-cfd" id="toc-chart-04-cfd">3.4 CFD -
            Cumulative Flow Diagram</a></li>
            <li><a href="#chart-05-sample-path-n"
            id="toc-chart-05-sample-path-n">3.5 N(t) - Process
            State</a></li>
            <li><a href="#chart-06-presence-mass-h"
            id="toc-chart-06-presence-mass-h">3.6 H(T) - Presence
            Mass</a></li>
            <li><a href="#chart-07-time-average-l"
            id="toc-chart-07-time-average-l">3.7 L(T) - Time-Average
            Presence</a></li>
            <li><a href="#chart-08-arrival-rate-lambda"
            id="toc-chart-08-arrival-rate-lambda">3.8 <span
            class="math inline">\(\Lambda(T)\)</span> - Arrival
            Rate</a></li>
            <li><a href="#chart-09-residence-w"
            id="toc-chart-09-residence-w">3.9 w(T) - Residence per
            Arrival</a></li>
            <li><a href="#chart-10-arrival-invariant"
            id="toc-chart-10-arrival-invariant">3.10 <span
            class="math inline">\(L(T)=\Lambda(T)\cdot w(T)\)</span>
            Invariant - Arrival Invariant</a></li>
            <li><a href="#chart-11-arrival-stack"
            id="toc-chart-11-arrival-stack">3.11 Arrival Stack - Arrival
            Dashboard</a></li>
            <li><a href="#chart-12-departure-rate-theta"
            id="toc-chart-12-departure-rate-theta">3.12 <span
            class="math inline">\(\Theta(T)\)</span> - Departure
            Rate</a></li>
            <li><a href="#chart-13-residence-w-prime"
            id="toc-chart-13-residence-w-prime">3.13 w’(T) - Residence
            per Departure</a></li>
            <li><a href="#chart-14-departure-invariant"
            id="toc-chart-14-departure-invariant">3.14 <span
            class="math inline">\(L(T)=\Theta(T)\cdot w&#39;(T)\)</span>
            Invariant - Departure Invariant</a></li>
            <li><a href="#chart-15-departure-stack"
            id="toc-chart-15-departure-stack">3.15 Departure Focused
            Stack - Departure Dashboard</a></li>
            </ul></li>
            <li><a href="#convergence-and-stability"
            id="toc-convergence-and-stability">4 Convergence and
            Stability</a>
            <ul>
            <li><a href="#chart-16-arrival-departure-rate-convergence"
            id="toc-chart-16-arrival-departure-rate-convergence">4.1
            <span class="math inline">\(\Lambda(T)\)</span>-<span
            class="math inline">\(\Theta(T)\)</span> Rate Convergence -
            Rate Convergence</a></li>
            <li><a href="#chart-17-process-time-convergence"
            id="toc-chart-17-process-time-convergence">4.2 Process Time
            Convergence - Time Convergence</a></li>
            <li><a href="#chart-20-sample-path-convergence"
            id="toc-chart-20-sample-path-convergence">4.3 Top-Level
            Convergence <span class="math inline">\(L(T)\)</span> vs
            <span class="math inline">\(\lambda^*(t)\cdot
            W^*(t)\)</span></a></li>
            </ul></li>
            </ul>
          </nav>
        </aside>
                <div class="doc-content">
          <h1 id="sample-path-flow-metrics">1 Sample Path Flow
          Metrics</h1>
          <p>This document is a catalog of charts generated by the
          sample path analysis toolkit.</p>
          <p>Given an input sample path (an arrival/departure point
          process, as shown above), all computations are deterministic.
          Every value depends only on event order and the elapsed time
          between events on that path.</p>
          <p>Each chart shows one or more metrics and their
          relationships to each other and to the underlying events on
          the sample path. At any point in time, each metric value can
          be traced to the <em>specific event(s)</em> that produced it.
          That is what enables reliable cause-and-effect analysis of
          flow-metric changes.</p>
          <p>None of these calculations are statistical summaries, and
          none rely on probabilistic assumptions. To repeat: given the
          input sample path, every value is fully determined.</p>
          <p>Another key feature: canonical sample path flow metrics are
          indexed by <em>events</em> on the sample path.
          Calendar-indexed views are derived samples of the same
          event-resolved calculations. For theory and formal definitions
          behind why this matters, see <a
          href="../../articles/theory">Sample Path Theory</a>.</p>
          <p>For CLI options and output contracts, see <a
          href="../../articles/cli">Command Line Reference</a>.</p>
          <h2 id="methodology">1.1 Methodology</h2>
          <p>Please see the article <a
          href="../../articles/a-methodological-contrast">Sample Path
          Analysis vs Statistics</a> about the deeper methodological
          contrasts between sample path analysis and current techniques
          for measuring flow metrics, and why these matter in accurate
          reasoning about flow.</p>
          <h1 id="notational-conventions">2 Notational Conventions</h1>
          <p>The charts are introduced in a canonical derivation arc
          starting with the sample path: each metric is derived
          deterministically from prior metrics or directly from the
          sample path itself. The reader is strongly encouraged to read
          these entries in order, as earlier entries introduce
          theoretical concepts and terminology in context, and they are
          assumed in later ones.</p>
          <h2 id="measurements">2.1 Measurements</h2>
          <p>All measurements are defined over an observation window
          with a <em>fixed</em> starting point that we will denote as
          <span class="math inline">\(0\)</span>. The underlying process
          may evolve stochastically or non-deterministically. At any
          moment, however, we work with the realized prefix of its
          sample path observed up to a finite horizon <span
          class="math inline">\(T_{\max}\)</span>. It is important to
          note that <span class="math inline">\(T_{\max}\)</span>
          denotes the <em>elapsed time</em> since the fixed origin <span
          class="math inline">\(0\)</span>, not an absolute
          timestamp.</p>
          <p>As more events are observed, additional portions of the
          sample path are revealed, the observable horizon extends, and
          the associated measurements are recomputed on the extended
          prefix.</p>
          <p>Given a realized sample path up to a fixed finite horizon,
          all measurements made over that prefix are deterministic. Even
          when the underlying process is non-deterministic, the
          measurements applied to the observed prefix are not.</p>
          <h2 id="notation">2.2 Notation</h2>
          <ul>
          <li><p>Lower-case <span class="math inline">\(t\)</span>
          denotes <em>instantaneous</em> time.<br />
          </p></li>
          <li><p>Upper-case <span class="math inline">\(T\)</span>
          denotes a <em>prefix horizon</em> of the observation interval,
          i.e. an interval <span class="math inline">\((0, T]\)</span>
          with <span class="math inline">\(0 &lt; T \le
          T_{\max}\)</span>.</p></li>
          <li><p>For a fixed horizon <span
          class="math inline">\(T\)</span>, the within-window time
          variable <span class="math inline">\(t\)</span> satisfies
          <span class="math inline">\(0 &lt; t \le T\)</span>.</p></li>
          <li><p>Functions of <span class="math inline">\(t\)</span>
          (such as <span class="math inline">\(N(t)\)</span>) denote
          instantaneous sample-path values at time <span
          class="math inline">\(t\)</span>.</p></li>
          <li><p>Functions of <span class="math inline">\(T\)</span>
          represent <em>cumulative quantities</em> or normalized
          quantities derived from them, computed over the interval <span
          class="math inline">\((0, T]\)</span>.</p>
          <p>For each <span class="math inline">\(T\)</span>, we
          consider the prefix window <span class="math inline">\((0,
          T]\)</span>. Endpoint quantities such as <span
          class="math inline">\(F(T)\)</span> are values determined by
          the prefix up to and including time <span
          class="math inline">\(T\)</span>, and as <span
          class="math inline">\(T\)</span> varies over <span
          class="math inline">\((0, T_{\max}]\)</span>, these endpoint
          values form the trajectory <span class="math inline">\(T
          \mapsto F(T)\)</span> which is what we display on all the
          charts by default.</p>
          <blockquote>
          <p>This uses the standard <a
          href="https://en.wikipedia.org/wiki/C%C3%A0dl%C3%A0g">càdlàg</a>
          convention for counting/jump processes: sample paths are
          right-continuous with left limits.</p>
          </blockquote></li>
          </ul>
          <p>All cumulative functions are deterministic, pathwise
          calculations (definite integrals, discrete sums, and
          finite-window normalizations) applied to the realized prefix
          and should not be confused with statistical measures or
          ensemble aggregates.</p>
          <h2 id="timescales-and-indexes">2.3 Timescales and
          Indexes</h2>
          <p>All charts use continuous time on the x-axis.</p>
          <ul>
          <li>In event-indexed views, points are evaluated at exact
          event timestamps from the input sample path.</li>
          <li>In calendar-indexed views, points are evaluated at
          calendar boundaries, but values are still computed from the
          same underlying event-resolved pathwise calculations.</li>
          </ul>
          <p>Internally, durations are measured in seconds and then
          durations and rates are converted automatically to a
          consistent scale suitable for human-friendly display. This
          automatic scaling of units happens <em>on the y-axis
          only</em>; the x-axis remains continuous time.</p>
          <p>Calendar indexing is simply a coarser <em>sampling
          grid</em> over <em>metrics</em> computed from the
          event-resolved sample path at the input granularity. We do not
          pre-aggregate events into calendar buckets and then compute
          flow metrics from those aggregates, like other flow metrics
          tools (incorrectly) do.</p>
          <p>All core charts shown in this document should be assumed to
          be event-indexed by default, unless explicitly specified
          otherwise.</p>
          <p>Although calendar dates may appear on the time axis as
          reference labels, the underlying x-axis values correspond to
          exact event timestamps. These timestamps are not constrained
          to fall on calendar reporting boundaries and may occur at
          arbitrary points in continuous time.</p>
          <h2 id="event-display">2.4 Event display</h2>
          <p>Event indexing is a key differentiator of sample path
          analysis, so charts are shown with event-resolved overlays by
          default: each plotted point is tied to an arrival or departure
          event. This makes the event-level impact on each flow-metric
          trajectory explicit. Arrival points are colored purple,
          departure points green, and each point includes a drop line to
          its x-axis timestamp. This detail is essential for
          deterministic cause-and-effect analysis.</p>
          <p>Each chart also has a <code>--no-events</code> version with
          overlays removed. These views are useful for higher-level
          gestalt analysis of trajectories across views, especially in
          dashboards. When reviewing these charts, I recommend you take
          a look at both views to build intuition.</p>
          <h1 id="the-presence-invariant">3 The Presence Invariant</h1>
          <p>The Presence Invariant is the finite-horizon form of
          Little’s Law.</p>
          <p><span class="math display">\[
          \begin{aligned}
          L(T) &amp;= \Lambda(T)\,w(T) = \Theta(T)\,w&#39;(T)
          \end{aligned}
          \]</span></p>
          <p>For the full derivation context and interpretation, refer
          to <a href="../../articles/theory#presence-invariant">Sample
          Path Theory: Presence Invariant</a>.</p>
          <p>The quantities in this law are the finite horizon
          equivalents of the quantities in the familiar steady state
          view of Little’s Law, But unlike the steady state version the
          presence invariant <em>holds unconditionally at all
          times</em>.</p>
          <p>This section shows the step-by-step derivation of each
          quantity in the invariant and visualizes how the values of
          each metric at every point in time are derived from the sample
          path. The charts are presented in a canonical order starting
          with the input sample path. Each chart depends on one or more
          metrics in an earlier chart. All calculations are
          deterministic.</p>
          <p>Review the theory doc and use it as a cross-reference when
          reviewing the charts below. The ideas here are relatively
          straightforward if you spend a little bit of time carefully
          reading, understanding and reviewing what each chart means and
          the sequence of derivations.</p>
          <table>
          <colgroup>
          <col style="width: 40%" />
          <col style="width: 26%" />
          <col style="width: 31%" />
          <col style="width: 2%" />
          </colgroup>
          <thead>
          <tr>
          <th>Chart</th>
          <th>Name</th>
          <th>Formula</th>
          <th>Units</th>
          </tr>
          </thead>
          <tbody>
          <tr>
          <td><a href="#chart-01-point-process">Point Process</a></td>
          <td>Sample Path</td>
          <td>Input event stream</td>
          <td>N/A</td>
          </tr>
          <tr>
          <td><a href="#chart-02-arrivals-a">A(T)</a></td>
          <td>Cumulative Arrivals</td>
          <td><span class="math inline">\(A(T)=\sum \text{arrivals in
          }(0,T]\)</span></td>
          <td>Elem</td>
          </tr>
          <tr>
          <td><a href="#chart-03-departures-d">D(T)</a></td>
          <td>Cumulative Departures</td>
          <td><span class="math inline">\(D(T)=\sum \text{departures in
          }(0,T]\)</span></td>
          <td>Elem</td>
          </tr>
          <tr>
          <td><a href="#chart-04-cfd">CFD</a></td>
          <td>Cumulative Flow Diagram</td>
          <td></td>
          <td>N/A</td>
          </tr>
          <tr>
          <td><a href="#chart-05-sample-path-n">N(t)</a></td>
          <td>Instantaneous Process State</td>
          <td><span class="math inline">\(N(t)=A(T)-D(T)\)</span></td>
          <td>Elem</td>
          </tr>
          <tr>
          <td><a href="#chart-06-presence-mass-h">H(T)</a></td>
          <td>Cumulative Presence Mass</td>
          <td><span class="math inline">\(H(T)=\int_0^T
          N(t)\,dt\)</span></td>
          <td>Elem-Time</td>
          </tr>
          <tr>
          <td><a href="#chart-07-time-average-l">L(T)</a></td>
          <td>(Time) Average State</td>
          <td><span class="math inline">\(L(T)=H(T)/T\)</span></td>
          <td>Elem</td>
          </tr>
          <tr>
          <td><a href="#chart-08-arrival-rate-lambda"><span
          class="math inline">\(\Lambda(T)\)</span></a></td>
          <td>Arrival Rate</td>
          <td><span
          class="math inline">\(\Lambda(T)=A(T)/T\)</span></td>
          <td>Elem/Time</td>
          </tr>
          <tr>
          <td><a href="#chart-09-residence-w">w(T)</a></td>
          <td>Residence Time per Arrival</td>
          <td><span class="math inline">\(w(T)=H(T)/A(T)\)</span></td>
          <td>Time</td>
          </tr>
          <tr>
          <td><a href="#chart-10-arrival-invariant">Arrival
          Invariant</a></td>
          <td>Arrivals Focused Invariant</td>
          <td><span class="math inline">\(L(T)=\Lambda(T)\cdot
          w(T)\)</span></td>
          <td>Elem</td>
          </tr>
          <tr>
          <td><a href="#chart-11-arrival-stack">Arrival Stack</a></td>
          <td>Arrival Focused Flow Dashboard</td>
          <td><span class="math inline">\(N(t), L(T), \Lambda(T),
          w(T)\)</span></td>
          <td>N/A</td>
          </tr>
          <tr>
          <td><a href="#chart-12-departure-rate-theta"><span
          class="math inline">\(\Theta(T)\)</span></a></td>
          <td>Departure Rate</td>
          <td><span class="math inline">\(\Theta(T)=D(T)/T\)</span></td>
          <td>Elem/Time</td>
          </tr>
          <tr>
          <td><a href="#chart-13-residence-w-prime">w’(T)</a></td>
          <td>Residence Time per Departure</td>
          <td><span
          class="math inline">\(w&#39;(T)=H(T)/D(T)\)</span></td>
          <td>Time</td>
          </tr>
          <tr>
          <td><a href="#chart-14-departure-invariant">Departure
          Invariant</a></td>
          <td>Departures Focused Invariant</td>
          <td><span class="math inline">\(N(t), L(T), \Theta(T),
          w&#39;(T)\)</span></td>
          <td>Elem</td>
          </tr>
          <tr>
          <td><a href="#chart-15-departure-stack">Departure
          Stack</a></td>
          <td>Departure Focused Flow Dashboard</td>
          <td><span class="math inline">\(L(T)=\Theta(T)\cdot
          w&#39;(T)\)</span></td>
          <td>N/A</td>
          </tr>
          </tbody>
          </table>
          <h2 id="chart-01-point-process">3.1 Point Process - Event
          Stream</h2>
          <p><code>with-events</code></p>
          <figure>
          <img
          src="../../articles/chart-reference/chart_reference_small/with-events/core/panels/arrival_departure_indicator_process.png"
          alt="Point Process (with-events)" />
          <figcaption aria-hidden="true">Point Process
          (with-events)</figcaption>
          </figure>
          <details>
          <summary>
          No-events version
          </summary>
          <figure>
          <img
          src="../../articles/chart-reference/chart_reference_small/no-events/core/panels/arrival_departure_indicator_process.png"
          alt="Point Process (no-events)" />
          <figcaption aria-hidden="true">Point Process
          (no-events)</figcaption>
          </figure>
          </details>
          <p>This is the sample path: the input to sample path analysis.
          It is the observed behavior of some operational process
          modeled as a sequence of arrival and departure events on a
          timeline.</p>
          <p>It is represented as a timestamped event sequence with an
          indicator (a mark) at each timestamp. Here the mark indicates
          whether an event is an arrival or a departure. For core
          Presence Invariant calculations, this is sufficient.</p>
          <p>The sample path encodes <em>non-deterministic process
          behavior</em> along two dimensions: the discrete sequence of
          event types (including the ordering of arrivals and
          departures), and the continuous inter-event durations.</p>
          <p>A useful mental model for the observable behavior of the
          underlying process is a simple coin flip observed over time.
          Each flip determines whether the next event is an arrival or a
          departure. In an arrival-departure process, however, we care
          about both dimensions of what is observed: the event outcome
          and the <em>elapsed time</em> to the next event.</p>
          <p>We call this class of non-deterministic models <em>flow
          processes</em>. The specific case where event type is binary
          (arrival or departure) is a <em>binary</em> flow process. The
          same machinery extends naturally to a broader class of
          non-deterministic marked point processes, but this library
          currently implements only the binary case.</p>
          <p>Note: An <code>id</code> mark that pairs arrivals with
          departures is <em>optional</em> for the core invariant
          metrics, but <em>required</em> for item-level sojourn-time
          measurements. This only becomes relevant when discussing
          convergence, stability and the familiar steady-state version
          of Little’s Law.</p>
          <p><strong>Output file:</strong>
          <code>core/panels/arrival_departure_indicator_process.png</code></p>
          <h2 id="chart-02-arrivals-a">3.2 A(T) - Cumulative
          Arrivals</h2>
          <p><code>with-events</code></p>
          <figure>
          <img
          src="../../articles/chart-reference/chart_reference_small/with-events/core/panels/cumulative_arrivals_A.png"
          alt="A(T) cumulative arrivals (with-events)" />
          <figcaption aria-hidden="true">A(T) cumulative arrivals
          (with-events)</figcaption>
          </figure>
          <details>
          <summary>
          No-events version
          </summary>
          <figure>
          <img
          src="../../articles/chart-reference/chart_reference_small/no-events/core/panels/cumulative_arrivals_A.png"
          alt="A(T) cumulative arrivals (no-events)" />
          <figcaption aria-hidden="true">A(T) cumulative arrivals
          (no-events)</figcaption>
          </figure>
          </details>
          <p><strong>Derivation:</strong> <span
          class="math inline">\(A(T)=\sum \text{arrivals in
          }(0,T]\)</span>.</p>
          <p><strong>Unit:</strong> Elements.</p>
          <p>The simplest measurement on the sample path is a
          <em>cumulative count</em>. In particular, for a moment <span
          class="math inline">\(T\)</span> in the observation window
          <span class="math inline">\((0, T_{\max}]\)</span>, we count
          the arrivals observed in the prefix interval <span
          class="math inline">\((0, T]\)</span>.</p>
          <p>Formally, following our convention, we define</p>
          <p><span class="math display">\[
          A(T)=\#\{\,i:\ 0 &lt; a_i \le T\,\}
          \]</span></p>
          <p>where <span class="math inline">\(a_i\)</span> is an
          arrival timestamp and <span class="math inline">\(\#\)</span>
          denotes set cardinality. In most contexts however, we will use
          the simpler but less precise notation shown in the derivation
          above.</p>
          <p>While this appears to be a simple metric, several important
          structural properties are worth highlighting, and they
          motivate conceptual distinctions that fundamentally separate
          sample path analysis from traditional statistical approaches
          to measuring flow.</p>
          <h3 id="events-define-measurements">Events define
          measurements</h3>
          <p>The key observation is that the trajectory of <span
          class="math inline">\(A(T)\)</span> is completely determined
          by discrete arrival events.</p>
          <ul>
          <li><span class="math inline">\(A(T)\)</span> is defined for
          all <span class="math inline">\(T \in (0, T_{\max}]\)</span>,
          so it is a function of time.</li>
          <li>It is a right-continuous step function that <em>increases
          by one at each arrival timestamp</em> and <em>is constant
          between arrival events</em>.</li>
          <li>Given the ordered arrival timestamps, the entire function
          is uniquely determined for all <span
          class="math inline">\(T\)</span>.</li>
          </ul>
          <p>The reader is urged to verify that these properties hold
          for the examples we have shown.</p>
          <h3 id="measurements-map-to-state">Measurements map to
          state</h3>
          <p>This stepwise structure naturally leads to the notion of
          process <em>state</em>.</p>
          <p>The value of <span class="math inline">\(A(T)\)</span> at a
          given time <span class="math inline">\(T\)</span> can be
          viewed as the state of the counting process at that moment. As
          <span class="math inline">\(T\)</span> increases, this state
          evolves over time. State transitions occur only at arrival
          timestamps, where <span class="math inline">\(A(T)\)</span>
          increases by one; between arrivals, the state remains
          constant.</p>
          <p><span class="math inline">\(A(T)\)</span> itself models a
          single dimensional state - a cumulative count of arrivals. As
          we will soon see, all flow metrics can be viewed as processes,
          that model higher dimensional states arising from the
          interactions of these lower dimensional states.</p>
          <h3 id="state-and-time-define-processes">State and time define
          processes</h3>
          <p>In stochastic process theory, a <em>process</em> is defined
          as a mapping from an index set to a state space. The counting
          process <span class="math inline">\(A(T)\)</span> is a simple
          example: it maps continuous time <span
          class="math inline">\(T\)</span> to the state space <span
          class="math inline">\(\mathbb{N}\)</span> of natural
          numbers.</p>
          <p>The same arrival structure can also be indexed by event
          order, yielding the embedded discrete-time sequence <span
          class="math inline">\(\{A(a_i)\}\)</span> evaluated at arrival
          times. These two parameterizations — time-indexed and
          event-indexed — describe the same underlying arrival
          process.</p>
          <blockquote>
          <p>In El-Taha and Stidham <span class="citation"
          data-cites="eltaha1999">[1]</span>, such processes are called
          <em>processes with an embedded point process</em>. We will use
          the more informal term <em>event-indexed</em> process
          throughout this document, with the assumption that such
          processes can be parametrized by event time stamps or
          continuous time.</p>
          </blockquote>
          <p>Another crucial observation is that these processes are
          deterministic <em>functionals</em> of the realized sample
          path. Each metric is obtained by applying a well-defined
          mapping, or a sequence of mappings, to the underlying sample
          path. This allows us to reason <em>deterministically</em>
          about how a change in the underlying events propagates through
          all derived processes over time, and to connect every quantity
          back to the original events via the event index.</p>
          <p>Think of these relationships like a series of cells
          updating on a spreadsheet. The next value of the metric
          depends upon the previous value and the <em>next event</em> on
          the sample path. This latter choice is non-deterministic.
          Everything after that is deterministically computed once that
          choice is resolved. Verify that this holds for <span
          class="math inline">\(A(T)\)</span>.</p>
          <p>Similar properties hold for <em>every</em> metric we
          compute. Our charts and exports emphasize the
          <em>event-indexed</em> nature of these functions over the
          sample path. This stands in stark contrast to statistical
          measures, where we typically speak only of correlations
          between aggregates rather than deterministic dependence.</p>
          <p><strong>Output file:</strong>
          <code>core/panels/cumulative_arrivals_A.png</code></p>
          <h2 id="chart-03-departures-d">3.3 D(T) - Cumulative
          Departures</h2>
          <p><code>with-events</code></p>
          <figure>
          <img
          src="../../articles/chart-reference/chart_reference_small/with-events/core/panels/cumulative_departures_D.png"
          alt="D(T) cumulative departures (with-events)" />
          <figcaption aria-hidden="true">D(T) cumulative departures
          (with-events)</figcaption>
          </figure>
          <details>
          <summary>
          No-events version
          </summary>
          <figure>
          <img
          src="../../articles/chart-reference/chart_reference_small/no-events/core/panels/cumulative_departures_D.png"
          alt="D(T) cumulative departures (no-events)" />
          <figcaption aria-hidden="true">D(T) cumulative departures
          (no-events)</figcaption>
          </figure>
          </details>
          <p>This is the identical construction as <span
          class="math inline">\(A(T)\)</span> but for departure marks.
          Like <span class="math inline">\(A(T)\)</span>, <span
          class="math inline">\(D(T)\)</span> is a right-continuous step
          function that increases by one at each departure timestamp and
          is constant between departures.</p>
          <p>The resulting process determines a new stateful process -
          the departure process.</p>
          <p><strong>Derivation:</strong> <span
          class="math inline">\(D(T)=\sum \text{departures in
          }(0,T]\)</span>.</p>
          <p><strong>Unit:</strong> Elements.</p>
          <p><strong>Output file:</strong>
          <code>core/panels/cumulative_departures_D.png</code></p>
          <h2 id="chart-04-cfd">3.4 CFD - Cumulative Flow Diagram</h2>
          <p><code>with-events</code></p>
          <figure>
          <img
          src="../../articles/chart-reference/chart_reference_small/with-events/core/panels/cumulative_flow_diagram.png"
          alt="CFD (with-events)" />
          <figcaption aria-hidden="true">CFD (with-events)</figcaption>
          </figure>
          <details>
          <summary>
          No-events version
          </summary>
          <figure>
          <img
          src="../../articles/chart-reference/chart_reference_small/no-events/core/panels/cumulative_flow_diagram.png"
          alt="CFD (no-events)" />
          <figcaption aria-hidden="true">CFD (no-events)</figcaption>
          </figure>
          </details>
          <p>The Cumulative Flow Diagram (CFD) is the central
          construction for modeling and measuring an arrival-departure
          process. It is not itself a metric, but a visualization that
          exposes the key variables governing flow.</p>
          <p>Mechanically, it consists of the two counting processes
          <span class="math inline">\(A(T)\)</span> and <span
          class="math inline">\(D(T)\)</span> plotted together over the
          same sample path. However, the superposition of these
          processes reveals geometric relationships that impose
          structural constraints on the behavior of the
          arrival–departure process over time.</p>
          <p>Before turning to the formal derivation, consider the
          intuition. If the arrival and departure curves are viewed as
          the bounding cumulative curves of the process, the shaded
          region between them represents a measurable quantity that
          accumulates over time. Since the horizontal axis is indexed by
          time, this region corresponds to a time-accumulated quantity
          that can be computed and reasoned about concretely. The
          accumulated area up to time <span
          class="math inline">\(T\)</span> therefore defines another
          process with its own state.</p>
          <p>We call this quantity <em>Presence Mass</em> (or simply
          <em>Presence</em>). Formally, it is the area between the
          arrival and departure curves over the interval <span
          class="math inline">\((0,T]\)</span>. Intuitively, it measures
          both:</p>
          <ul>
          <li>how many elements are present in the process (the vertical
          separation between the curves), and<br />
          </li>
          <li>for how long those elements remain present (the horizontal
          extent over time).</li>
          </ul>
          <p>Larger areas correspond to greater presence mass in the
          system; smaller areas correspond to less.</p>
          <p>The interpretation of presence mass is entirely
          context-dependent. If arrivals represent new customers,
          greater presence mass may be desirable. If arrivals represent
          defects, smaller presence mass is preferable. Sample path flow
          analysis does not assign meaning to the quantities; it
          measures and characterizes the structure of flow through
          presence mass in a systematic and mathematically consistent
          way.</p>
          <p>Presence mass — the area between the bounding curves — is a
          measurable quantity, <span
          class="math inline">\(H(T)\)</span>, representing accumulated
          presence over the interval <span
          class="math inline">\((0,T]\)</span>. Together, the counting
          processes <span class="math inline">\(A(\cdot)\)</span> and
          <span class="math inline">\(D(\cdot)\)</span> — and
          equivalently the derived quantity <span
          class="math inline">\(H(T)\)</span> — form a sufficient state
          description for the classical arrival–departure flow
          model.</p>
          <p>All standard flow metrics — including time averages,
          throughput rates, and finite-window variants of Little’s Law —
          can be expressed as deterministic functionals of the counting
          processes <span class="math inline">\(A(\cdot)\)</span> and
          <span class="math inline">\(D(\cdot)\)</span>.</p>
          <p>Before introducing <span
          class="math inline">\(H(T)\)</span> formally, we begin with an
          even simpler quantity: the instantaneous state of the
          arrival–departure process.</p>
          <p><strong>Output file:</strong>
          <code>core/panels/cumulative_flow_diagram.png</code></p>
          <h2 id="chart-05-sample-path-n">3.5 N(t) - Process State</h2>
          <p><code>with-events</code></p>
          <figure>
          <img
          src="../../articles/chart-reference/chart_reference_small/with-events/core/panels/sample_path_N.png"
          alt="N(t) sample path (with-events)" />
          <figcaption aria-hidden="true">N(t) sample path
          (with-events)</figcaption>
          </figure>
          <details>
          <summary>
          No-events version
          </summary>
          <figure>
          <img
          src="../../articles/chart-reference/chart_reference_small/no-events/core/panels/sample_path_N.png"
          alt="N(t) sample path (no-events)" />
          <figcaption aria-hidden="true">N(t) sample path
          (no-events)</figcaption>
          </figure>
          </details>
          <p><strong>Derivation:</strong> <span
          class="math inline">\(N(t)=A(T)-D(T)\)</span>.</p>
          <p><strong>Unit:</strong> Elements.</p>
          <p>The first thing the CFD allows us to do is determine how
          many elements are present in the process (have arrived but not
          departed) at any instant of time. On the CFD, this is just the
          vertical distance between the <span
          class="math inline">\(A(T)\)</span> and <span
          class="math inline">\(D(T)\)</span> lines.</p>
          <p>We may define this as a new process <span
          class="math display">\[ N(t) = A(T) - D(T)\]</span></p>
          <blockquote>
          <p>Note: Here <span class="math inline">\(A(T)\)</span> and
          <span class="math inline">\(D(T)\)</span> are cumulative
          functions on <span class="math inline">\((0,T]\)</span>, and
          we set <span class="math inline">\(t:=T\)</span> at the
          endpoint; their difference at each <span
          class="math inline">\(T\)</span> is the instantaneous state
          <span class="math inline">\(N(t)\)</span>.</p>
          </blockquote>
          <p><span class="math inline">\(N(t)\)</span> is the
          instantaneous number of elements present in the
          arrival-departure process. This is the quantity we commonly
          call WIP in software contexts.</p>
          <p>The plot of <span class="math inline">\(N(t)\)</span>
          against the event timeline is called the <em>process
          state</em> chart because, viewed as a process, it is
          interpretable as an instantaneous state variable of the
          arrival-departure process.</p>
          <ul>
          <li>An arrival event causes it to increase by 1</li>
          <li>A departure event causes it to decrease by 1</li>
          <li>Like <span class="math inline">\(A(T)\)</span> and <span
          class="math inline">\(D(T)\)</span>, <span
          class="math inline">\(N(t)\)</span> changes only at event
          boundaries, remaining constant in between.</li>
          </ul>
          <blockquote>
          <p>In summary, the arrival and departure events change the
          state of the arrival-departure process with <span
          class="math inline">\(N(t)\)</span> capturing the state as the
          net <em>effect</em> of cumulative arrivals and departures.</p>
          </blockquote>
          <p>One thing that may not be immediately obvious, but is true
          nevertheless, is that the shared grey area under the <span
          class="math inline">\(N(t)\)</span> curve is exactly the same
          area between the arrival and departure lines in the CFD. The
          differences are mainly due to scaling and display, but the
          shaded area represents the same quantity, the Presence Mass we
          saw in the CFD.</p>
          <p>Generally speaking, the process state plot gives us a
          simpler and more operationally useful way of examining and
          reasoning about presence, and so for the most part, we will
          rely on <span class="math inline">\(N(t)\)</span> as the core
          flow metric upon which we build the rest of the metrics in the
          Presence Invariant.</p>
          <p><strong>Output file:</strong>
          <code>core/panels/sample_path_N.png</code></p>
          <h2 id="chart-06-presence-mass-h">3.6 H(T) - Presence
          Mass</h2>
          <p><code>with-events</code></p>
          <figure>
          <img
          src="../../articles/chart-reference/chart_reference_small/with-events/core/panels/cumulative_presence_mass_H.png"
          alt="H(T) presence mass (with-events)" />
          <figcaption aria-hidden="true">H(T) presence mass
          (with-events)</figcaption>
          </figure>
          <details>
          <summary>
          No-events version
          </summary>
          <figure>
          <img
          src="../../articles/chart-reference/chart_reference_small/no-events/core/panels/cumulative_presence_mass_H.png"
          alt="H(T) presence mass (no-events)" />
          <figcaption aria-hidden="true">H(T) presence mass
          (no-events)</figcaption>
          </figure>
          </details>
          <p><strong>Derivation:</strong> <span
          class="math inline">\(H(T)=\int_0^T N(t)\,dt\)</span>.</p>
          <p><strong>Unit:</strong> Elements-Time.</p>
          <p>In addition to the number of elements present at any
          instant, the CFD also visualizes how long they were present.
          To make this notion precise, examine the <span
          class="math inline">\(N(t)\)</span> chart carefully. Since
          <span class="math inline">\(N(t)\)</span> changes value only
          at event boundaries and remains constant between them, each
          interval between changes can be interpreted as the time the
          arrival–departure process remains in a given state.</p>
          <p>Each rectangular segment under the <span
          class="math inline">\(N(t)\)</span> path represents a
          time-weighted accumulation of presence mass in that state.
          This is the incremental presence mass generated while the
          process remained at that cardinality.</p>
          <p>The cumulative presence mass added over an interval <span
          class="math inline">\((0,T]\)</span> is the sum of these
          rectangles. More generally, it is expressed as the definite
          integral of <span class="math inline">\(N(t)\)</span>, which
          also captures any partial accumulation between events:</p>
          <p><span class="math display">\[
          H(T) = \int_0^T N(t)\,dt
          \]</span></p>
          <blockquote>
          <p>Note that presence mass lives in a product space of
          elements and time and that this the units of <span
          class="math inline">\(H(T)\)</span> are element-time.</p>
          </blockquote>
          <p>Now when <span class="math inline">\(H(T)\)</span> is
          plotted against time, it inherits structural properties from
          <span class="math inline">\(N(t)\)</span>:</p>
          <ul>
          <li>Events change the trajectory of <span
          class="math inline">\(H(T)\)</span>.</li>
          <li>Between events, the path increases linearly.</li>
          <li>The slope of the path between events is <span
          class="math inline">\(N(t)\)</span>, the instantaneous state
          of the process over that interval.</li>
          <li>Arrival events increase the slope; departures decrease the
          slope.</li>
          <li>The path is flat when <span
          class="math inline">\(N(t)=0\)</span>.</li>
          </ul>
          <p>The reader is encouraged to compare the charts of <span
          class="math inline">\(N(t)\)</span> and <span
          class="math inline">\(H(T)\)</span> and confirm that this
          structure holds exactly. Like its inputs, <span
          class="math inline">\(H(T)\)</span> is a deterministic
          functional of the realized sample path of <span
          class="math inline">\(N(t)\)</span>. Once the trajectory of
          <span class="math inline">\(N(t)\)</span> over <span
          class="math inline">\((0,T]\)</span> is known, the value of
          <span class="math inline">\(H(T)\)</span> is uniquely
          determined: <span class="math inline">\(H(T)\)</span> is
          obtained purely by integrating the observed path.</p>
          <blockquote>
          <p><span class="math inline">\(H(T)\)</span> encodes a simple
          rule: higher cardinality process states accumulate presence at
          a faster rate.</p>
          </blockquote>
          <p>Whether this is desirable depends on context. In a
          development setting, where <span
          class="math inline">\(N(t)\)</span> represents WIP, presence
          corresponds to delay exposure, and higher <span
          class="math inline">\(N(t)\)</span> implies delay is
          accumulating more rapidly. In a customer service context,
          presence may represent active customer engagement, implying
          faster growth in retained customers. The mathematics is
          agnostic to interpretation; only the objective changes.</p>
          <blockquote>
          <p>This makes <span class="math inline">\(H(T)\)</span> the
          minimal integrated variable that captures the history of
          process states over <span
          class="math inline">\((0,T]\)</span>. While <span
          class="math inline">\(N(t)\)</span> captures the instantaneous
          state, <span class="math inline">\(H(T)\)</span> captures the
          accumulated presence generated by that state over time. In
          this sense, <span class="math inline">\(H(T)\)</span>
          compresses the entire past evolution of <span
          class="math inline">\(N(t)\)</span> into a single scalar
          quantity that evolves over time.</p>
          </blockquote>
          <p><strong>Output file:</strong>
          <code>core/panels/cumulative_presence_mass_H.png</code></p>
          <h2 id="chart-07-time-average-l">3.7 L(T) - Time-Average
          Presence</h2>
          <p><code>with-events</code></p>
          <figure>
          <img
          src="../../articles/chart-reference/chart_reference_small/with-events/core/panels/time_average_N_L.png"
          alt="L(T) time average (with-events)" />
          <figcaption aria-hidden="true">L(T) time average
          (with-events)</figcaption>
          </figure>
          <details>
          <summary>
          No-events version
          </summary>
          <figure>
          <img
          src="../../articles/chart-reference/chart_reference_small/no-events/core/panels/time_average_N_L.png"
          alt="L(T) time average (no-events)" />
          <figcaption aria-hidden="true">L(T) time average
          (no-events)</figcaption>
          </figure>
          </details>
          <p>Builds on <span class="math inline">\(H(T)\)</span> by
          normalizing by elapsed time, yielding time-average
          presence.</p>
          <p><strong>Derivation:</strong> <span
          class="math inline">\(L(T)=H(T)/T\)</span>.</p>
          <p><strong>Unit:</strong> Elements.</p>
          <p><strong>Output file:</strong>
          <code>core/panels/time_average_N_L.png</code></p>
          <h2 id="chart-08-arrival-rate-lambda">3.8 <span
          class="math inline">\(\Lambda(T)\)</span> - Arrival Rate</h2>
          <p><code>with-events</code></p>
          <figure>
          <img
          src="../../articles/chart-reference/chart_reference_small/with-events/core/panels/cumulative_arrival_rate_Lambda.png"
          alt="Lambda(T) arrival rate (with-events)" />
          <figcaption aria-hidden="true">Lambda(T) arrival rate
          (with-events)</figcaption>
          </figure>
          <details>
          <summary>
          No-events version
          </summary>
          <figure>
          <img
          src="../../articles/chart-reference/chart_reference_small/no-events/core/panels/cumulative_arrival_rate_Lambda.png"
          alt="Lambda(T) arrival rate (no-events)" />
          <figcaption aria-hidden="true">Lambda(T) arrival rate
          (no-events)</figcaption>
          </figure>
          </details>
          <p>Builds on cumulative arrivals by converting counts to
          elapsed-time-normalized arrival rate.</p>
          <p><strong>Derivation:</strong> <span
          class="math inline">\(\Lambda(T)=A(T)/T\)</span>.</p>
          <p><strong>Unit:</strong> Elements/Time.</p>
          <p><strong>Output file:</strong>
          <code>core/panels/cumulative_arrival_rate_Lambda.png</code></p>
          <h2 id="chart-09-residence-w">3.9 w(T) - Residence per
          Arrival</h2>
          <p><code>with-events</code></p>
          <figure>
          <img
          src="../../articles/chart-reference/chart_reference_small/with-events/core/panels/average_residence_time_w.png"
          alt="w(T) residence per arrival (with-events)" />
          <figcaption aria-hidden="true">w(T) residence per arrival
          (with-events)</figcaption>
          </figure>
          <details>
          <summary>
          No-events version
          </summary>
          <figure>
          <img
          src="../../articles/chart-reference/chart_reference_small/no-events/core/panels/average_residence_time_w.png"
          alt="w(T) residence per arrival (no-events)" />
          <figcaption aria-hidden="true">w(T) residence per arrival
          (no-events)</figcaption>
          </figure>
          </details>
          <p>Builds on <span class="math inline">\(H(T)\)</span> and
          <span class="math inline">\(A(T)\)</span> by expressing
          accumulated presence per arrival as average residence per
          arrival.</p>
          <p><strong>Derivation:</strong> <span
          class="math inline">\(w(T)=H(T)/A(T)\)</span>.</p>
          <p><strong>Unit:</strong> Time.</p>
          <p><strong>Output file:</strong>
          <code>core/panels/average_residence_time_w.png</code></p>
          <h2 id="chart-10-arrival-invariant">3.10 <span
          class="math inline">\(L(T)=\Lambda(T)\cdot w(T)\)</span>
          Invariant - Arrival Invariant</h2>
          <p><code>with-events</code></p>
          <figure>
          <img
          src="../../articles/chart-reference/chart_reference_small/with-events/core/panels/littles_law_invariant.png"
          alt="Arrival invariant (with-events)" />
          <figcaption aria-hidden="true">Arrival invariant
          (with-events)</figcaption>
          </figure>
          <details>
          <summary>
          No-events version
          </summary>
          <figure>
          <img
          src="../../articles/chart-reference/chart_reference_small/no-events/core/panels/littles_law_invariant.png"
          alt="Arrival invariant (no-events)" />
          <figcaption aria-hidden="true">Arrival invariant
          (no-events)</figcaption>
          </figure>
          </details>
          <p>Builds on Steps 7-9a by verifying the finite-window
          arrival-side invariant at each observation point.</p>
          <p><strong>Derivation:</strong> <span
          class="math inline">\(L(T)=\Lambda(T)\cdot w(T)\)</span>.</p>
          <p><strong>Unit:</strong> Elements.</p>
          <p><strong>Output file:</strong>
          <code>core/panels/littles_law_invariant.png</code></p>
          <h2 id="chart-11-arrival-stack">3.11 Arrival Stack - Arrival
          Dashboard</h2>
          <p><code>with-events</code></p>
          <figure>
          <img
          src="../../articles/chart-reference/chart_reference_small/with-events/sample_path_flow_metrics.png"
          alt="Arrival stack (with-events)" />
          <figcaption aria-hidden="true">Arrival stack
          (with-events)</figcaption>
          </figure>
          <details>
          <summary>
          No-events version
          </summary>
          <figure>
          <img
          src="../../articles/chart-reference/chart_reference_small/no-events/sample_path_flow_metrics.png"
          alt="Arrival stack (no-events)" />
          <figcaption aria-hidden="true">Arrival stack
          (no-events)</figcaption>
          </figure>
          </details>
          <p>Builds on Steps 5, 7, 8, and 9a by presenting the
          arrival-side state, average, rate, and residence components on
          one aligned dashboard.</p>
          <p><strong>Derivation:</strong> <span
          class="math inline">\(L(T)=\Lambda(T)\cdot w(T)\)</span>.</p>
          <p><strong>Unit:</strong> Mixed (Elements, Elements/Time,
          Time).</p>
          <p><strong>Output file:</strong>
          <code>sample_path_flow_metrics.png</code></p>
          <h2 id="chart-12-departure-rate-theta">3.12 <span
          class="math inline">\(\Theta(T)\)</span> - Departure Rate</h2>
          <p><code>with-events</code></p>
          <figure>
          <img
          src="../../articles/chart-reference/chart_reference_small/with-events/core/panels/cumulative_departure_rate_Theta.png"
          alt="Theta(T) departure rate (with-events)" />
          <figcaption aria-hidden="true">Theta(T) departure rate
          (with-events)</figcaption>
          </figure>
          <details>
          <summary>
          No-events version
          </summary>
          <figure>
          <img
          src="../../articles/chart-reference/chart_reference_small/no-events/core/panels/cumulative_departure_rate_Theta.png"
          alt="Theta(T) departure rate (no-events)" />
          <figcaption aria-hidden="true">Theta(T) departure rate
          (no-events)</figcaption>
          </figure>
          </details>
          <p>Builds from the departure count path by converting
          cumulative departures to elapsed-time-normalized departure
          rate.</p>
          <p><strong>Derivation:</strong> <span
          class="math inline">\(\Theta(T)=D(T)/T\)</span>.</p>
          <p><strong>Unit:</strong> Elements/Time.</p>
          <p><strong>Output file:</strong>
          <code>core/panels/cumulative_departure_rate_Theta.png</code></p>
          <h2 id="chart-13-residence-w-prime">3.13 w’(T) - Residence per
          Departure</h2>
          <p><code>with-events</code></p>
          <figure>
          <img
          src="../../articles/chart-reference/chart_reference_small/with-events/core/panels/average_residence_time_w_prime.png"
          alt="w’(T) residence per departure (with-events)" />
          <figcaption aria-hidden="true">w’(T) residence per departure
          (with-events)</figcaption>
          </figure>
          <details>
          <summary>
          No-events version
          </summary>
          <figure>
          <img
          src="../../articles/chart-reference/chart_reference_small/no-events/core/panels/average_residence_time_w_prime.png"
          alt="w’(T) residence per departure (no-events)" />
          <figcaption aria-hidden="true">w’(T) residence per departure
          (no-events)</figcaption>
          </figure>
          </details>
          <p>Builds on <span class="math inline">\(H(T)\)</span> and
          <span class="math inline">\(D(T)\)</span> by expressing
          accumulated presence per departure.</p>
          <p><strong>Derivation:</strong> <span
          class="math inline">\(w&#39;(T)=H(T)/D(T)\)</span>.</p>
          <p><strong>Unit:</strong> Time.</p>
          <p><strong>Output file:</strong>
          <code>core/panels/average_residence_time_w_prime.png</code></p>
          <h2 id="chart-14-departure-invariant">3.14 <span
          class="math inline">\(L(T)=\Theta(T)\cdot w&#39;(T)\)</span>
          Invariant - Departure Invariant</h2>
          <p><code>with-events</code></p>
          <figure>
          <img
          src="../../articles/chart-reference/chart_reference_small/with-events/core/panels/departure_littles_law_invariant.png"
          alt="Departure invariant (with-events)" />
          <figcaption aria-hidden="true">Departure invariant
          (with-events)</figcaption>
          </figure>
          <details>
          <summary>
          No-events version
          </summary>
          <figure>
          <img
          src="../../articles/chart-reference/chart_reference_small/no-events/core/panels/departure_littles_law_invariant.png"
          alt="Departure invariant (no-events)" />
          <figcaption aria-hidden="true">Departure invariant
          (no-events)</figcaption>
          </figure>
          </details>
          <p>Builds on Steps 7, 11, and 12 by verifying <span
          class="math inline">\(L(T)=\Theta(T)\cdot w&#39;(T)\)</span>
          pointwise.</p>
          <p><strong>Derivation:</strong> <span
          class="math inline">\(L(T)=\Theta(T)\cdot
          w&#39;(T)\)</span>.</p>
          <p><strong>Unit:</strong> Elements.</p>
          <p><strong>Output file:</strong>
          <code>core/panels/departure_littles_law_invariant.png</code></p>
          <h2 id="chart-15-departure-stack">3.15 Departure Focused Stack
          - Departure Dashboard</h2>
          <p><code>with-events</code></p>
          <figure>
          <img
          src="../../articles/chart-reference/chart_reference_small/with-events/core/departure_flow_metrics.png"
          alt="Departure stack (with-events)" />
          <figcaption aria-hidden="true">Departure stack
          (with-events)</figcaption>
          </figure>
          <details>
          <summary>
          No-events version
          </summary>
          <figure>
          <img
          src="../../articles/chart-reference/chart_reference_small/no-events/core/departure_flow_metrics.png"
          alt="Departure stack (no-events)" />
          <figcaption aria-hidden="true">Departure stack
          (no-events)</figcaption>
          </figure>
          </details>
          <p>Builds on Steps 5, 7, 11, and 12 by presenting the
          departure-side dashboard in aligned panels.</p>
          <p><strong>Derivation:</strong> <span
          class="math inline">\(L(T)=\Theta(T)\cdot
          w&#39;(T)\)</span>.</p>
          <p><strong>Unit:</strong> Mixed (Elements, Elements/Time,
          Time).</p>
          <p><strong>Output file:</strong>
          <code>core/departure_flow_metrics.png</code></p>
          <h1 id="convergence-and-stability">4 Convergence and
          Stability</h1>
          <table>
          <colgroup>
          <col style="width: 25%" />
          <col style="width: 25%" />
          <col style="width: 25%" />
          <col style="width: 25%" />
          </colgroup>
          <thead>
          <tr>
          <th>Chart</th>
          <th>Short Name</th>
          <th>Formula</th>
          <th>Units</th>
          </tr>
          </thead>
          <tbody>
          <tr>
          <td><a
          href="#chart-16-arrival-departure-rate-convergence"><span
          class="math inline">\(\Lambda(T)\)</span>-<span
          class="math inline">\(\Theta(T)\)</span> Rate
          Convergence</a></td>
          <td>Rate Convergence</td>
          <td><span class="math inline">\(\Lambda(T)=A(T)/T\)</span> vs
          <span class="math inline">\(\Theta(T)=D(T)/T\)</span></td>
          <td>Elem/Time</td>
          </tr>
          <tr>
          <td><a href="#chart-17-process-time-convergence">Process Time
          Convergence</a></td>
          <td>Time Convergence</td>
          <td><span class="math inline">\(w(T)=H(T)/A(T)\)</span> vs
          <span class="math inline">\(W^*(t)\)</span></td>
          <td>Time</td>
          </tr>
          <tr>
          <td><a href="#chart-20-sample-path-convergence">Top-Level
          Convergence <span class="math inline">\(L(T)\)</span> vs <span
          class="math inline">\(\lambda^*(t)\cdot
          W^*(t)\)</span></a></td>
          <td>Top-Level Convergence</td>
          <td><span class="math inline">\(L(T)\)</span> vs <span
          class="math inline">\(\lambda^*(t)\cdot W^*(t)\)</span></td>
          <td>Elem</td>
          </tr>
          </tbody>
          </table>
          <h2 id="chart-16-arrival-departure-rate-convergence">4.1 <span
          class="math inline">\(\Lambda(T)\)</span>-<span
          class="math inline">\(\Theta(T)\)</span> Rate Convergence -
          Rate Convergence</h2>
          <p><code>no-events</code></p>
          <figure>
          <img
          src="../../articles/chart-reference/chart_reference_small/no-events/convergence/panels/arrival_departure_rate_convergence.png"
          alt="Arrival-departure rate convergence (no-events)" />
          <figcaption aria-hidden="true">Arrival-departure rate
          convergence (no-events)</figcaption>
          </figure>
          <details>
          <summary>
          With-events version
          </summary>
          <figure>
          <img
          src="../../articles/chart-reference/chart_reference_small/with-events/convergence/panels/arrival_departure_rate_convergence.png"
          alt="Arrival-departure rate convergence (with-events)" />
          <figcaption aria-hidden="true">Arrival-departure rate
          convergence (with-events)</figcaption>
          </figure>
          </details>
          <p>Builds from Steps 8 and 11 by directly comparing cumulative
          arrival and departure rate trajectories.</p>
          <p><strong>Derivation:</strong> <span
          class="math inline">\(\Lambda(T)=A(T)/T\)</span> vs <span
          class="math inline">\(\Theta(T)=D(T)/T\)</span>.</p>
          <p><strong>Unit:</strong> Elements/Time.</p>
          <p><strong>Output file:</strong>
          <code>convergence/panels/arrival_departure_rate_convergence.png</code></p>
          <h2 id="chart-17-process-time-convergence">4.2 Process Time
          Convergence - Time Convergence</h2>
          <p><code>no-events</code></p>
          <figure>
          <img
          src="../../articles/chart-reference/chart_reference_small/no-events/convergence/panels/process_time_convergence.png"
          alt="Process time convergence (no-events)" />
          <figcaption aria-hidden="true">Process time convergence
          (no-events)</figcaption>
          </figure>
          <details>
          <summary>
          With-events version
          </summary>
          <figure>
          <img
          src="../../articles/chart-reference/chart_reference_small/with-events/convergence/panels/process_time_convergence.png"
          alt="Process time convergence (with-events)" />
          <figcaption aria-hidden="true">Process time convergence
          (with-events)</figcaption>
          </figure>
          </details>
          <p>Builds from Step 9a by comparing finite-window residence
          behavior to empirical process-time behavior.</p>
          <p><strong>Derivation:</strong> <span
          class="math inline">\(w(T)=H(T)/A(T)\)</span> vs <span
          class="math inline">\(W^*(t)\)</span>.</p>
          <p><strong>Unit:</strong> Time.</p>
          <p><strong>Output file:</strong>
          <code>convergence/panels/process_time_convergence.png</code></p>
          <h2 id="chart-20-sample-path-convergence">4.3 Top-Level
          Convergence <span class="math inline">\(L(T)\)</span> vs <span
          class="math inline">\(\lambda^*(t)\cdot W^*(t)\)</span></h2>
          <p><code>no-events</code></p>
          <figure>
          <img
          src="../../articles/chart-reference/chart_reference_small/no-events/sample_path_convergence.png"
          alt="Sample path convergence (no-events)" />
          <figcaption aria-hidden="true">Sample path convergence
          (no-events)</figcaption>
          </figure>
          <details>
          <summary>
          With-events version
          </summary>
          <figure>
          <img
          src="../../articles/chart-reference/chart_reference_small/with-events/sample_path_convergence.png"
          alt="Sample path convergence (with-events)" />
          <figcaption aria-hidden="true">Sample path convergence
          (with-events)</figcaption>
          </figure>
          </details>
          <p>Builds on the full chain by giving a top-level convergence
          diagnostic for the finite-window Little’s Law relation over
          the observation horizon.</p>
          <p><strong>Derivation:</strong> <span
          class="math inline">\(L(T)\)</span> vs <span
          class="math inline">\(\lambda^*(t)\cdot W^*(t)\)</span>.</p>
          <p><strong>Unit:</strong> Elements.</p>
          <p><strong>Output file:</strong>
          <code>sample_path_convergence.png</code></p>
          <div id="refs" class="references csl-bib-body"
          data-entry-spacing="0" role="list">
          <div id="ref-eltaha1999" class="csl-entry" role="listitem">
          <div class="csl-left-margin">[1] </div><div
          class="csl-right-inline">M. El-Taha and S. Stidham,
          <em>Sample-path analysis of queueing systems</em>, vol. 11. in
          International series in operations research &amp; management
          science, vol. 11. Boston, MA: Springer Science &amp; Business
          Media, 1999, p. 295.</div>
          </div>
          </div>
        </div>
      </div>
            <footer id="presence-link" role="contentinfo">
        <a href="https://samplepath.pcalc.org" target="_blank" rel="noreferrer">The Sample Path Analysis Toolkit</a>
        <div style="margin-top: 0.35rem; font-size: 0.85rem; color: #555;">
          © 2025 Krishna Kumar. All rights reserved.
        </div>
      </footer>
    </div>
  </div>
  <div class="lightbox-overlay" id="image-lightbox" aria-hidden="true">
    <button class="lightbox-close" id="lightbox-close" aria-label="Close image overlay" type="button">×</button>
    <img id="lightbox-image" alt="Expanded chart image" />
  </div>
  <script>
    (function () {
      var container = document.querySelector(".doc-content");
      if (!container) return;

      var overlay = document.getElementById("image-lightbox");
      var overlayImage = document.getElementById("lightbox-image");
      var closeBtn = document.getElementById("lightbox-close");
      if (!overlay || !overlayImage || !closeBtn) return;

      var lastFocused = null;

      function openLightbox(img) {
        var src = img.getAttribute("src");
        if (!src) return;
        lastFocused = document.activeElement;
        overlayImage.setAttribute("src", src);
        overlayImage.setAttribute("alt", img.getAttribute("alt") || "Expanded chart image");
        overlay.classList.add("is-open");
        overlay.setAttribute("aria-hidden", "false");
        closeBtn.focus();
      }

      function closeLightbox() {
        overlay.classList.remove("is-open");
        overlay.setAttribute("aria-hidden", "true");
        overlayImage.setAttribute("src", "");
        if (lastFocused && typeof lastFocused.focus === "function") {
          lastFocused.focus();
        }
      }

      var images = container.querySelectorAll("img");
      images.forEach(function (img) {
        if (img.closest(".header-image")) return;
        img.classList.add("lightboxable");
        img.setAttribute("tabindex", "0");
        img.setAttribute("role", "button");
        img.setAttribute("aria-label", (img.getAttribute("alt") || "Image") + ". Click to expand.");

        var fig = img.closest("figure");
        if (fig) fig.classList.add("has-lightbox");

        img.addEventListener("click", function () { openLightbox(img); });
        img.addEventListener("keydown", function (ev) {
          if (ev.key === "Enter" || ev.key === " ") {
            ev.preventDefault();
            openLightbox(img);
          }
        });
      });

      closeBtn.addEventListener("click", closeLightbox);
      overlay.addEventListener("click", function (ev) {
        if (ev.target === overlay) closeLightbox();
      });

      document.addEventListener("keydown", function (ev) {
        if (ev.key === "Escape" && overlay.classList.contains("is-open")) {
          closeLightbox();
        }
      });
    })();
  </script>
</body>
</html>
