<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Some questions on Sample Path Analysis</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }

    html {
      box-sizing: border-box;
      font-size: 100%;
    }

    *, *:before, *:after {
      box-sizing: inherit;
    }

    body {
      margin: 0;
      padding: 0;
      font-family: Nunito, Arial, sans-serif;
      font-size: 1.1rem;
      line-height: 1.75;
      background: #fff;
      color: #111;

      /* Remove Pandoc's injected width restrictions */
      max-width: none !important;
      padding-left: 0 !important;
      padding-right: 0 !important;
      padding-top: 0 !important;
      padding-bottom: 0 !important;
    }

    .wrapper {
      display: flex;
      justify-content: center;
    }

    #page {
      max-width: 880px;
      width: 100%;
      padding: 2rem 1rem;
    }

    h1, h2, h3, h4 {
      font-weight: bold;
      margin-top: 2rem;
      margin-bottom: 1rem;
      line-height: 1.4;
    }

    p {
      margin: 1.25rem 0;
    }

    img {
      max-width: 100%;
      height: auto;
      display: block;
      margin: 2rem auto;
    }

    pre {
      background: #f8f8f8;
      padding: 1rem;
      overflow-x: auto;
      border-radius: 6px;
    }

    code {
      font-family: SFMono-Regular, Consolas, monospace;
      background: #f5f5f5;
      padding: 0.2em 0.4em;
      border-radius: 4px;
    }

    blockquote {
      margin: 2rem 0;
      padding-left: 1rem;
      border-left: 4px solid #ddd;
      color: #666;
      font-style: italic;
    }

    .subtitle, .author, .date {
      color: #666;
      font-size: 0.9rem;
      margin-top: 0.5rem;
      text-align: center;
    }

    nav#TOC {
      margin: 2rem 0;
      padding: 1rem;
      border: 1px solid #eee;
      background: #fafafa;
      overflow-x: auto;
    }

    figure {
      margin: 2rem auto;
      text-align: center;
    }

    figure img {
      width: 100%;
      height: auto;
      display: block;
      margin: 2rem auto;
    }

    figcaption {
      font-size: 0.9em;
      color: #555;
      margin-top: 0.75rem;
    }

    header#title-block-header {
      text-align: center;
    }

    #presence-link {
      margin: 3rem auto 0;
      padding: 1.25rem 1rem 1.5rem;
      text-align: center;
      font-size: 0.95rem;
      color: #444;
      border-top: 1px solid #e5e7ea;
      background: #f9f9f9;
      border-radius: 8px 8px 0 0;
    }

    #presence-link a {
      text-decoration: none;
      color: #222;
      font-weight: 600;
    }

    #presence-link a:hover {
      text-decoration: underline;
    }

    .site-nav {
      margin: 0 auto 2rem;
      padding: 0.75rem 1rem;
      background: #f6f7f8;
      border: 1px solid #e5e7ea;
      border-radius: 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem 1.25rem;
      justify-content: center;
      font-size: 0.98rem;
    }

    .site-nav a {
      color: #222;
      text-decoration: none;
      font-weight: 600;
      padding: 0.2rem 0.35rem;
    }

    .site-nav a:hover {
      text-decoration: underline;
    }


    @media screen and (min-width: 1024px) {
      body {
        font-size: 1.15rem;
      }

      #page {
        padding: 3rem 2rem;
      }
    }

  </style>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
</head>
<body>
  <div class="wrapper">
    <div id="page">
      <nav class="site-nav" aria-label="Primary">
        <a href="https://samplepath.pcalc.org/index.html">Home</a>
        <a href="https://samplepath.pcalc.org/articles/package-overview/index.html">Package Overview</a>
        <a href="https://samplepath.pcalc.org/articles/cli/index.html">Command Line</a>
        <a href="https://samplepath.pcalc.org/articles/chart-reference/index.html">Chart Reference</a>
        <a href="https://samplepath.pcalc.org/examples/README.html">Examples</a>
      </nav>
                  <header id="title-block-header">
        <h1 class="title"><strong>Some questions on Sample Path
Analysis</strong></h1>

        <p class="author"><p><a href=""><em>Dr. Krishna
Kumar</em></a></p></p>

              </header>
                        <h1 id="background">Background</h1>
                        <p>Last week at Flowtopia, I gave a presentation
                        on Sample Path Analysis — a method for measuring
                        and reasoning about flow that starts from
                        fundamentally different assumptions than most of
                        the techniques we use today.</p>
                        <p>The ideas themselves are not new. The theory
                        has been around for nearly 50 years and is well
                        established in queueing theory and stochastic
                        process literature. But it has largely remained
                        within academic circles. Over the past four
                        years, my work has focused on understanding that
                        theory deeply and adapting it for practical use
                        in operational analysis of real-world digital
                        delivery systems.</p>
                        <p>I’ve been cautious about speaking publicly on
                        this topic. I wanted to make sure I understood
                        it thoroughly and could validate that it had
                        concrete, practical value — not just theoretical
                        appeal.</p>
                        <p>The series I wrote on Little’s Law in the
                        Polaris Flow Dispatch was my first attempt to
                        lay out the historical context and mathematical
                        foundations of these ideas. It covered the roots
                        and the broader implications, but not yet the
                        mechanics.</p>
                        <p>What I’m doing now — starting with the
                        Flowtopia sessions — is opening up the
                        mechanics. I want to make the underlying method
                        accessible to others in the flow community who
                        may want to apply it. At the same time, I’m
                        learning how to communicate these ideas more
                        clearly to a wider audience.</p>
                        <p>After the workshop, Thorsten Speil reached
                        out on LinkedIn with several thoughtful
                        questions. He generously agreed to let me
                        publish them along with my responses so others
                        can benefit from the discussion.</p>
                        <p>If this exchange raises additional questions
                        for you, feel free to post them. I’m happy to
                        continue the conversation.</p>
                        <h1
                        id="thorstens-questions-reproduced-verbatim">Thorsten’s
                        Questions (reproduced verbatim)</h1>
                        <blockquote>
                        <p>Hello Krishna! I watched the recording of
                        your Flow metrics Flowtopia webinar from Feb 5
                        and have some questions, if you like.</p>
                        </blockquote>
                        <pre><code>* I understand that in the regular way to e. g. calculate &quot;average WIP&quot; over some fixed time-window like a week or a month, you get a pretty jittery chart over time, so it can be hard to tell what is a real signal and what is not. Do I understand one of your critiques here right, or how would you phrase it?
  - Q1: wouldn&#39;t it still be possible to draw an upper and lower control limit into this &quot;jitter-chart&quot; to get some idea of when we see &quot;real&quot; trends?
  - Q2: if my tool doesn&#39;t allow sample path analysis and I want a &quot;working approximation&quot;, couldn&#39;t I just calculate and chart a moving average over past 3, 6, 12 months? That should &quot;calm down&quot; the chart and move a lot closer to the real behaviour?

You advise to use &quot;both&quot; in parallel, right? The sample path metrics for tracking &quot;slower&quot; changes, plus more tactical metrics on a shorter time-scale?

Q3: I don&#39;t recall you try to define &quot;arrival&quot; and &quot;departure&quot;. The times in which an element counts as entering the system or leaving it needs to be consistent for all elements.

Steve Tendon tries to make this more precise for his &quot;Flow Time&quot; calculation. You know his segmentation, I guess? He says, otherwise, people often measure so differently and have so much &quot;fluff&quot; in their metrics that they become pretty unreliable.
What do you think of that?

I attached a chart from Steve&#39;s TameFlow book to this post.
&quot;Flow Time&quot; is just one part of the overall end-to-end time.
From what I understand you might advise a company to a) decide what would be valuable for them to track over time - like duration of quotes or prioritization of requirements or development etc. ... then b) define their &quot;start&quot; and &quot;end&quot; times for these segments each and start calculating the respective sample paths? So if you want to track 3 different types of work, (&quot;quote&quot;, &quot;prioritization&quot;, &quot;development&quot;), then you would get sample path metrics for each of those separately?

If you find these questions good to explain more of the differences and your &quot;point&quot;, we can gladly post these/your answers elsewhere &quot;publicly&quot; on LI, Flowtopia, ...

Best regards! Thorsten</code></pre>
                        <p>Lets take each of these questions in turn, as
                        they are all very important in understanding
                        some of the subtle but important ways in which
                        sample path analysis fundamentally differs from
                        current techniques for measuring flow.</p>
                        <h2 id="what-is-average-wip">What is “Average
                        WIP”?</h2>
                        <blockquote>
                        <p>I understand that in the regular way to e. g.
                        calculate “average WIP” over some fixed
                        time-window like a week or a month, you get a
                        pretty jittery chart over time, so it can be
                        hard to tell what is a real signal and what is
                        not. Do I understand one of your critiques here
                        right, or how would you phrase it?</p>
                        </blockquote>
                        <p>The jitter is part of the problem, but it’s
                        not the main issue.</p>
                        <p>The deeper question is: <em>what does
                        “average WIP” actually mean?</em></p>
                        <p>Most existing books and tools don’t define
                        Average WIP carefully or compute it correctly —
                        if they compute it at all. They measure
                        <em>instantaneous WIP</em>, and if they produce
                        an “average,” it is often an arithmetic average
                        of those sampled instantaneous values.</p>
                        <p>The tell-tale sign is the x-axis of the CFD.
                        If it is indexed by calendar periods — days,
                        weeks, months — then you have already discarded
                        the information needed to compute “Average WIP”
                        correctly. Even Dan Vacanti’s <em>Actionable
                        Agile</em> does this, and that is how most of us
                        were originally introduced to CFDs.</p>
                        <p>The arrival and departure lines in a
                        precisely constructed CFD are always step
                        charts. They jump between values at events and
                        stay constant in between.</p>
                        <p>When defined properly, WIP itself is a
                        discrete <em>state</em> variable for the
                        process. When WIP changes, the process
                        transitions state. This happens <em>only when
                        events occur</em> (arrivals or departures).
                        Let:</p>
                        <ul>
                        <li><span class="math inline">\(N(t)\)</span> =
                        instantaneous WIP = <span
                        class="math inline">\(A(T) - D(T)\)</span> This
                        is the difference between <em>cumulative</em>
                        arrivals and departures over a time interval and
                        represents the <em>instantaneous</em> value of
                        WIP at the end point of that interval.</li>
                        </ul>
                        <p><span class="math inline">\(N(t)\)</span> is
                        also a step chart, but it can go up and down
                        unlike the two lines in the CFD. But like the
                        lines in the CFD it can only jump at event
                        times.</p>
                        <p>Now we can talk about <em>Average WIP</em>.
                        This is a time average not an arithmetic
                        average.</p>
                        <ul>
                        <li><span class="math inline">\(L(T)\)</span> =
                        time-average WIP over <span
                        class="math inline">\([0,T]\)</span></li>
                        </ul>
                        <p>defined as</p>
                        <p><span class="math display">\[
                        L(T) = \frac{1}{T} \int_0^T N(t)\,dt
                        \]</span></p>
                        <p><span class="math inline">\(L(T)\)</span> is
                        an “average state”, taken with respect to time.
                        More precisely, a <em>time-weighted average</em>
                        of the states the process occupied over the
                        observation window. It is fundamentally
                        different from <span
                        class="math inline">\(N(t)\)</span>.</p>
                        <p>Also, its not a statistical average. There is
                        no sampling or distributions involved.</p>
                        <p>For example, suppose over a 30-day window the
                        process spends:</p>
                        <ul>
                        <li>5 days at WIP = 4<br />
                        </li>
                        <li>20 days at WIP = 1<br />
                        </li>
                        <li>5 days at WIP = 0</li>
                        </ul>
                        <p>Then the time-average WIP is:</p>
                        <p><span class="math display">\[
                        \frac{5 \times 4 + 20 \times 1 + 5 \times 0}{30}
                        = \frac{40}{30}
                        = 1.33
                        \]</span></p>
                        <blockquote>
                        <p>The key is that durations here are not
                        multiples of reporting/sampling intervals. It is
                        an <em>exact accounting of time spent in each
                        state</em>, between events that drive the state
                        changes, normalized by the window length. This
                        quantity is what appears on the left-hand side
                        of Little’s Law.</p>
                        </blockquote>
                        <p>The LHS quantity in Little’s Law is not <span
                        class="math inline">\(N(t)\)</span>. Even
                        Actionable Agile confuses this, and I am yet to
                        find a flow metrics tool that computes this
                        correctly.</p>
                        <blockquote>
                        <ul>
                        <li>Q1: wouldn’t it still be possible to draw an
                        upper and lower control limit into this
                        “jitter-chart” to get some idea of when we see
                        “real” trends?</li>
                        <li>Q2: if my tool doesn’t allow sample path
                        analysis and I want a “working approximation”,
                        couldn’t I just calculate and chart a moving
                        average over past 3, 6, 12 months? That should
                        “calm down” the chart and move a lot closer to
                        the real behaviour?</li>
                        </ul>
                        </blockquote>
                        <p>Once you start sampling arrivals and
                        departures at fixed reporting intervals and
                        computing CFDs and metrics from those samples,
                        you have already moved away from the true object
                        that determines flow, and with it any hope of
                        leveraging the true value of Little’s Law -
                        cause and effect reasoning.</p>
                        <p>From that point on, the issue is not whether
                        you use moving averages, percentiles, or control
                        limits on the base data afterward. The issue is
                        that once you discard event ordering and exact
                        timing, you have lost the ability to reason
                        about the “real behavior” using the physics of
                        flow.</p>
                        <p>Sample path analysis makes two
                        commitments:</p>
                        <ol type="1">
                        <li>The sample path preserves the exact event
                        order and the exact elapsed time between
                        events.</li>
                        <li>Every metric is computed directly from that
                        event-indexed path, so each change in any metric
                        can be traced to the event that caused it to
                        change, in the order it occurred on the event
                        timeline.</li>
                        </ol>
                        <p>That gives you deterministic cause-and-effect
                        traceability. There is no ambiguity about why a
                        metric has the value it has. Each value of a
                        sample path flow metric at a point in time
                        carries with it the event that caused it to take
                        on that value. This deterministic behavior is
                        the key to why everything works.</p>
                        <p>Statistical summaries can work when the
                        system is already stable and observation windows
                        are long relative to average residence time. In
                        manufacturing environments, that condition often
                        holds. In digital delivery, it almost always
                        does not.</p>
                        <p>All these calculations are correctly
                        implemented in this toolkit. The most direct way
                        to understand the difference is to run both
                        approaches on your own data and compare what
                        they actually measure. I give you very detailed
                        charts that let you look at each computation
                        step separately and how the <em>events</em>
                        drive the metrics. Each of these charts is
                        independently useful if you are trying to really
                        diagnose flow problems, but in general, the
                        summary stacks are what you look at most of the
                        time.</p>
                        <blockquote>
                        <p>You advise to use “both” in parallel, right?
                        The sample path metrics for tracking “slower”
                        changes, plus more tactical metrics on a shorter
                        time-scale?</p>
                        </blockquote>
                        <p>My answer would be that you are free to use
                        any tool, provided you understand the
                        limitations. Current flow metrics tools treat
                        flow metrics as statistical artifacts, and in
                        doing so they make a category error. It’s not a
                        question of slower vs faster changes. N(t)
                        accurately measures changes at the finest
                        necessary granularity (this is lost when we
                        sample). L(T) allows you to accurately assess
                        long run implications. Long run residence times
                        capture both sojourn time and aging in a single
                        metric and are the correct metric for process
                        time at all timescales rather than the way we
                        currently measure cycle time and age
                        separately.</p>
                        <p>So the question is whether the flow metrics
                        you calculate are fit for purpose.</p>
                        <p>You can continue to use existing tools if you
                        are satisfied with having somewhat rough and
                        largely gut-feel perceptions of the state of
                        flow. They are useful that way. Drawing trend
                        charts, scatter plots, visualizing patterns in
                        the data etc,thinking in terms of leading and
                        lagging metrics all have their uses. But the
                        underlying measurements are ad hoc.</p>
                        <p>The main difference is that sample path
                        analysis gives provably correct and verifiable
                        calculations for flow metrics with precise cause
                        and effect semantics. So if you ask me, to
                        precisely measure, diagnose and improve flow,
                        sample path analysis is the only option. There
                        is just a little bit of a learning curve in
                        understanding why they work, and we could
                        probably use nicer tools that build upon the
                        things in this toolkit.</p>
                        <h2
                        id="defining-process-time-and-setting-boundaries">Defining
                        process time and setting boundaries</h2>
                        <blockquote>
                        <p>Q3: I don’t recall you try to define
                        “arrival” and “departure”. The times in which an
                        element counts as entering the system or leaving
                        it needs to be consistent for all elements.</p>
                        <p>Steve Tendon tries to make this more precise
                        for his “Flow Time” calculation. You know his
                        segmentation, I guess? He says, otherwise,
                        people often measure so differently and have so
                        much “fluff” in their metrics that they become
                        pretty unreliable.<br />
                        What do you think of that?</p>
                        <p>I attached a chart from Steve’s TameFlow book
                        to this post.<br />
                        “Flow Time” is just one part of the overall
                        end-to-end time.</p>
                        </blockquote>
                        <p>As you can see from Steve’s diagram, there
                        are many possible ways to define arrivals and
                        departures. Each segment in that picture can be
                        interpreted as a state, and an arrival or
                        departure can be defined as the event in which
                        an element enters or leaves that state.</p>
                        <p>But these are modeling choices.</p>
                        <p>A flow process is fully defined once we
                        specify:</p>
                        <ol type="1">
                        <li>What constitutes an element.<br />
                        </li>
                        <li>An event that marks its entry (to
                        something).<br />
                        </li>
                        <li>An event that marks its exit (from
                        something).</li>
                        </ol>
                        <p>Once those are defined consistently,
                        everything else in sample path analysis follows
                        mechanically.</p>
                        <p>Little’s Law does not require knowledge of
                        the internal structure of the system. It
                        requires only that arrivals and departures are
                        well-defined and that arrivals precede
                        departures for each element. If we violate those
                        constraints, the metrics behave pathologically
                        (for example, negative WIP becomes possible).
                        But once those basic causal rules are respected,
                        the mathematics is completely determined by the
                        event sequence and time between events.</p>
                        <p>The power of sample path analysis is that it
                        operates on behavior — the ordered sequence of
                        observed events — rather than on structural
                        descriptions of stages or workflows. Structure
                        can be layered on top, but it is not required
                        for the core invariants to hold.</p>
                        <p>In practical situations, of course, we often
                        care about multi-stage or nested processes. As
                        in Steve’s example, we might distinguish:</p>
                        <ul>
                        <li>Order-to-Cash<br />
                        </li>
                        <li>Flow Time within development<br />
                        </li>
                        <li>Quote preparation time</li>
                        </ul>
                        <p>Each of these is simply a different flow
                        process defined by a different pair of entry and
                        exit events. Each has its own:</p>
                        <ul>
                        <li>WIP process<br />
                        </li>
                        <li>Presence mass<br />
                        </li>
                        <li>Time-average WIP<br />
                        </li>
                        <li>Residence time</li>
                        <li>Sojourn time</li>
                        </ul>
                        <p>The Presence Invariant applies independently
                        to each one. Flow Time, Order-to-Cash are just
                        names we give to sojourn time for each of these
                        flow processes so that we can tell them apart
                        once we look at the system of flow processes as
                        a whole. This is all modeling.</p>
                        <p>When processes are nested, the state becomes
                        richer. Instead of a single WIP value, we may
                        track a vector of WIP values across internal
                        states. But mathematically, this is still
                        constructed from a single event timeline with
                        appropriately marked events.</p>
                        <p>Ultimately, flow analysis reduces to modeling
                        state transitions and the time spent in state by
                        accurate accounting on the event timeline. That
                        requires:</p>
                        <ul>
                        <li>Measuring all quantities against the same
                        event-indexed timeline.<br />
                        </li>
                        <li>Using consistent definitions of entry and
                        exit.<br />
                        </li>
                        <li>Computing all metrics over the same
                        observation window.</li>
                        </ul>
                        <p>This last condition is where most existing
                        flow metrics break down. It is common to see WIP
                        sampled at one time, throughput computed over a
                        different window, and cycle time averaged over
                        yet another window. Once the observation windows
                        are inconsistent, the presence invariant fails
                        to hold, and the causal interpretation is
                        lost.</p>
                        <p>Understanding structure is useful. But for
                        reasoning about flow, what matters most is
                        understanding behavior — the sequence of events
                        and the durations between them.</p>
                        <p>That said, so far, none of what I have talked
                        about, written, or implemented in code,
                        addresses these more complex configurations of
                        flow processes. This is on my to-do list once I
                        get the basic ideas of sample path analysis for
                        simple flow process with a single element and
                        single entry/exit event pair, written down and
                        communicated.</p>
            <footer id="presence-link" role="contentinfo">
        <a href="https://samplepath.pcalc.org" target="_blank" rel="noreferrer">The Sample Path Analysis Toolkit</a>
        <div style="margin-top: 0.35rem; font-size: 0.85rem; color: #555;">
          © 2025 Krishna Kumar. All rights reserved.
        </div>
      </footer>
    </div>
  </div>
</body>
</html>
