---
title: <strong>Chart Reference</strong>
author: |
  <a href="https://github.com/presence-calculus/samplepath"><em>The Samplepath Analysis Toolkit</em></a>

document-root: ../..
header-image: $document-root/articles/chart-reference/chart_reference_small/with-events/core/panels/arrival_departure_indicator_process.png

# Configure TOC
toc: true
toc-title: Contents
toc-depth: 2
# Configure section numbers
numberSections: true
sectionsDepth: 2
# Configure figures
figPrefix: Figure
# Configure citations
citations: true
---

# Sample Path Flow Metrics

This document is a catalog of charts generated by the sample path analysis toolkit.

Given an input sample path (an arrival/departure point process, as shown above), all
computations are deterministic. Every value depends only on event order and the elapsed
time between events on that path.

Each chart shows one or more metrics and their relationships to each other and to the
underlying events on the sample path. At any point in time, each metric value can be
traced to the _specific event(s)_ that produced it. That is what enables reliable
cause-and-effect analysis of flow-metric changes.

None of these calculations are statistical summaries, and none rely on probabilistic
assumptions. To repeat: given the input sample path, every value is fully determined.

Another key feature: canonical sample path flow metrics are indexed by _events_ on the
sample path. Calendar-indexed views are derived samples of the same event-resolved
calculations.
For theory and
formal definitions behind why this matters, see [Sample Path Theory]($document-root/articles/theory).

For CLI options and output contracts, see [Command Line Reference]($document-root/articles/cli).

## Methodology
Please see the article [Sample Path Analysis vs Statistics]($document-root/articles/a-methodological-contrast) about the deeper methodological contrasts between sample path analysis and current techniques for measuring flow metrics, and why these matter
in accurate reasoning about flow.


# Notational Conventions

The charts are introduced in a canonical derivation arc starting with the sample path: each metric is
derived deterministically from prior metrics or directly from the sample path itself. The reader
is strongly encouraged to read these entries in order, as earlier entries introduce theoretical concepts
and terminology in context, and they are assumed in later ones.

## Measurements

All measurements are defined over an observation window with a _fixed_ starting point that we will denote as $0$. The underlying process may evolve stochastically or non-deterministically. At any moment, however, we work with the realized prefix of its sample path observed up to a finite horizon $T_{\max}$. It is  important to note that $T_{\max}$ denotes the _elapsed time_ since the fixed origin $0$, not an absolute timestamp.

As more events are observed, additional portions of the sample path are revealed, the observable horizon extends, and the associated measurements are recomputed on the extended prefix.

Given a realized sample path up to a fixed finite horizon, all measurements made over that prefix are deterministic. Even when the underlying process is non-deterministic, the measurements applied to the observed prefix are not.

## Notation

- Lower-case $t$ denotes *instantaneous* time.  
- Upper-case $T$ denotes a *prefix horizon* of the observation interval, i.e. an interval $(0, T]$ with $0 < T \le T_{\max}$.

- For a fixed horizon $T$, the within-window time variable $t$ satisfies $0 < t \le T$.

- Functions of $t$ (such as $N(t)$) denote instantaneous sample-path values at time $t$.

- Functions of $T$ represent *cumulative quantities* or normalized quantities derived from them, computed over the interval $(0, T]$.

  For each $T$, we consider the prefix window $(0, T]$. Endpoint quantities such as $F(T)$ are values determined by the prefix up to and including time $T$, and as $T$ varies over $(0, T_{\max}]$, these endpoint values form the trajectory $T \mapsto F(T)$ which is what we display on all the charts by default.

  > This uses the standard [càdlàg](https://en.wikipedia.org/wiki/C%C3%A0dl%C3%A0g) convention for counting/jump processes: sample paths are right-continuous with left limits.

All cumulative functions are deterministic, pathwise calculations (definite integrals, discrete sums, and finite-window normalizations) applied to the realized prefix and should not be confused with statistical measures or ensemble aggregates.


## Timescales and Indexes

All charts use continuous time on the x-axis.

- In event-indexed views, points are evaluated at exact event timestamps from the
  input sample path.
- In calendar-indexed views, points are evaluated at calendar boundaries, but values
  are still computed from the same underlying event-resolved pathwise calculations.

Internally, durations are measured in seconds and then durations and rates are converted automatically
to a consistent scale suitable for human-friendly display. This automatic scaling of units happens _on the y-axis only_;
the x-axis remains continuous time.

Calendar indexing is simply a coarser *sampling grid* over _metrics_ computed from the
event-resolved sample path at the input granularity. We do not pre-aggregate events into calendar buckets and then
compute flow metrics from those aggregates, like other flow metrics tools (incorrectly) do.

All core charts shown in this document should be assumed to be event-indexed by default, unless explicitly specified otherwise.

Although calendar dates may appear on the time axis as reference labels, the underlying x-axis values correspond to exact event timestamps. These timestamps are not constrained to fall on calendar reporting boundaries and may occur at arbitrary points in continuous time.

## Event display

Event indexing is a key differentiator of sample path analysis, so charts are shown with event-resolved overlays by default: each plotted point is tied to an arrival or departure event. This makes the event-level impact on each flow-metric trajectory explicit. Arrival points are colored purple, departure points green, and each point includes a drop line to its x-axis timestamp. This detail is essential for deterministic cause-and-effect analysis.

Each chart also has a `--no-events` version with overlays removed. These views are useful for higher-level gestalt analysis of trajectories across views, especially in dashboards. When reviewing these charts, I recommend you take a look at both views to build intuition.



# The Presence Invariant

The Presence Invariant is the finite-horizon form of Little’s Law.

$$
\begin{aligned}
L(T) &= \Lambda(T)\,w(T) = \Theta(T)\,w'(T)
\end{aligned}
$$

For the full derivation context and interpretation, refer to [Sample Path Theory: Presence Invariant]($document-root/articles/theory#presence-invariant).

The quantities in this law are the finite horizon equivalents of the quantities in the familiar steady state view of Little's Law,
But unlike the steady state version the presence invariant _holds unconditionally at all times_.

This section shows the step-by-step derivation of each quantity in the invariant and visualizes how the values of each metric at evry point in time are derived from the sample path. The charts are presented in a canonical order starting with the input sample path. Each chart depends on one more more metrics in an earlier chart. All calculations are deterministic.

Review the theory doc and use it as a cross-reference when reviewing the charts below. The ideas here are relatively straightforward if you spend a little bit of time carefully reading, understanding and reviewing what each chart means and the sequence of derivations.



| Chart                                              | Name                             | Formula                                | Units |
|----------------------------------------------------|----------------------------------|----------------------------------------| --- |
| [Point Process](#chart-01-point-process)           | Sample Path                      | Input event stream                     | N/A |
| [A(T)](#chart-02-arrivals-a)                       | Cumulative Arrivals              | $A(T)=\sum \text{arrivals in }(0,T]$   | Elem |
| [D(T)](#chart-03-departures-d)                     | Cumulative Departures            | $D(T)=\sum \text{departures in }(0,T]$ | Elem |
| [CFD](#chart-04-cfd)                               | Cumulative Flow Diagram          |                                        | N/A |
| [N(t)](#chart-05-sample-path-n)                    | Instantaneous Process State      | $N(t)=A(T)-D(T)$                       | Elem |
| [H(T)](#chart-06-presence-mass-h)                  | Cumulative Presence Mass         | $H(T)=\int_0^T N(t)\,dt$               | Elem-Time |
| [L(T)](#chart-07-time-average-l)                   | (Time) Average State             | $L(T)=H(T)/T$                          | Elem |
| [$\Lambda(T)$](#chart-08-arrival-rate-lambda)      | Arrival Rate                     | $\Lambda(T)=A(T)/T$                    | Elem/Time |
| [w(T)](#chart-09-residence-w)                      | Residence Time per Arrival       | $w(T)=H(T)/A(T)$                       | Time |
| [Arrival Invariant](#chart-10-arrival-invariant)   | Arrivals Focused Invariant       | $L(T)=\Lambda(T)\cdot w(T)$            | Elem |
| [Arrival Stack](#chart-11-arrival-stack)           | Arrival Focused Flow Dashboard   | $N(t), L(T), \Lambda(T), w(T)$         | N/A |
| [$\Theta(T)$](#chart-12-departure-rate-theta)      | Departure Rate                   | $\Theta(T)=D(T)/T$                     | Elem/Time |
| [w'(T)](#chart-13-residence-w-prime)               | Residence Time per Departure     | $w'(T)=H(T)/D(T)$                      | Time |
| [Departure Invariant](#chart-14-departure-invariant) | Departures Focused Invariant     | $N(t), L(T), \Theta(T), w'(T)$         | Elem |
| [Departure Stack](#chart-15-departure-stack)       | Departure Focused Flow Dashboard | $L(T)=\Theta(T)\cdot w'(T)$            | N/A |



## Point Process - Event Stream {#chart-01-point-process}

`with-events`

![Point Process (with-events)]($document-root/articles/chart-reference/chart_reference_small/with-events/core/panels/arrival_departure_indicator_process.png)

<details>
<summary>No-events version</summary>

![Point Process (no-events)]($document-root/articles/chart-reference/chart_reference_small/no-events/core/panels/arrival_departure_indicator_process.png)

</details>

This is the sample path: the input to sample path analysis. It is the observed behavior of some operational process modeled as a sequence of arrival and departure events on a timeline.

It is represented as a timestamped event sequence with an indicator (a mark) at each timestamp. Here the mark indicates whether an event is an arrival or a departure. For core Presence Invariant calculations, this is sufficient.

The sample path encodes _non-deterministic process behavior_ along two dimensions: the discrete sequence of event types (including the ordering of arrivals and departures), and the continuous inter-event durations.

A useful mental model for the observable behavior of the underlying process is a simple coin flip observed over time. Each flip determines whether the next event is an arrival or a departure. In an arrival-departure process, however, we care about both dimensions of what is observed: the event outcome and the _elapsed time_ to the next event.

We call this class of non-deterministic models _flow processes_. The specific case where event type is binary (arrival or departure) is a _binary_ flow process. The same machinery extends naturally to a broader class of non-deterministic marked point processes, but this library currently implements only the binary case.

Note: An `id` mark that pairs arrivals with departures is _optional_ for the core invariant metrics, but _required_ for item-level sojourn-time measurements. This only becomes relevant when discussing convergence, stability and the familiar steady-state version of Little's Law.

**Output file:** `core/panels/arrival_departure_indicator_process.png`

## A(T) - Cumulative Arrivals {#chart-02-arrivals-a}

`with-events`

![A(T) cumulative arrivals (with-events)]($document-root/articles/chart-reference/chart_reference_small/with-events/core/panels/cumulative_arrivals_A.png)

<details>
<summary>No-events version</summary>

![A(T) cumulative arrivals (no-events)]($document-root/articles/chart-reference/chart_reference_small/no-events/core/panels/cumulative_arrivals_A.png)

</details>

**Derivation:** $A(T)=\sum \text{arrivals in }(0,T]$.

**Unit:** Elements.

The simplest measurement on the sample path is a _cumulative count_. In particular, for a moment $T$ in the observation window $(0, T_{\max}]$, we count the arrivals observed in the prefix interval $(0, T]$.

Formally, following our convention, we define

$$
A(T)=\#\{\,i:\ 0 < a_i \le T\,\}
$$

where $a_i$ is an arrival timestamp and $\#$ denotes set cardinality. In most contexts however, we will use the simpler but less precise notation shown in the derivation above.

While this appears to be a simple metric, several important structural properties are worth highlighting, and they motivate conceptual distinctions that fundamentally separate sample path analysis from traditional statistical approaches to measuring flow.

### Events define measurements

The key observation is that the trajectory of $A(T)$ is completely determined by discrete arrival events.

- $A(T)$ is defined for all $T \in (0, T_{\max}]$, so it is a function of time.
- It is a right-continuous step function that _increases by one at each arrival timestamp_ and _is constant between arrival events_.
- Given the ordered arrival timestamps, the entire function is uniquely determined for all $T$.

The reader is urged to verify that these properties hold for the examples we have shown.

### Measurements map to state

This stepwise structure naturally leads to the notion of process _state_.

The value of $A(T)$ at a given time $T$ can be viewed as the state of the counting process at that moment. As $T$ increases, this state evolves over time. State transitions occur only at arrival timestamps, where $A(T)$ increases by one; between arrivals, the state remains constant.

$A(T)$ itself models a single dimensional state - a cumulative count of arrivals. As we will soon see, all flow metrics can be viewed as processes, that model higher dimensional states arising from the interactions
of these lower dimensional states.


### State and time define processes

In stochastic process theory, a _process_ is defined as a mapping from an index set to a state space. The counting process $A(T)$ is a simple example: it maps continuous time $T$ to the state space $\mathbb{N}$ of natural numbers.

The same arrival structure can also be indexed by event order, yielding the embedded discrete-time sequence $\{A(a_i)\}$ evaluated at arrival times. These two parameterizations — time-indexed and event-indexed — describe the same underlying arrival process.

>In El-Taha and Stidham [@eltaha1999], such processes are called _processes with an embedded point process_. We will use the more informal term _event-indexed_ process throughout this document, with the assumption that such processes can be parametrized by event time stamps or continuous time.



Another crucial observation is that these processes are deterministic _functionals_ of the realized sample path. Each metric is obtained by applying a well-defined mapping, or a sequence of mappings, to the underlying sample path. This allows us to reason _deterministically_ about how a change in the underlying events propagates through all derived processes over time, and to connect every quantity back to the original events via the event index.

Think of these relationships like a series of cells updating on a spreadsheet. The next value of the metric depends upon the previous value and the _next event_ on the sample path. This latter choice is non-deterministic. Everything after that is deterministically computed once that choice is resolved. Verify that this holds for $A(T)$.

Similar properties hold for _every_ metric we compute. Our charts and exports emphasize the _event-indexed_ nature of these functions over the sample path. This stands in stark contrast to statistical measures, where we typically speak only of correlations between aggregates rather than deterministic dependence.


**Output file:** `core/panels/cumulative_arrivals_A.png`


## D(T) - Cumulative Departures {#chart-03-departures-d}

`with-events`

![D(T) cumulative departures (with-events)]($document-root/articles/chart-reference/chart_reference_small/with-events/core/panels/cumulative_departures_D.png)

<details>
<summary>No-events version</summary>

![D(T) cumulative departures (no-events)]($document-root/articles/chart-reference/chart_reference_small/no-events/core/panels/cumulative_departures_D.png)

</details>

This is the identical construction as $A(T)$ but for departure marks. Like $A(T)$, $D(T)$ is a right-continuous step function that increases by one at each departure timestamp and is constant between departures.

The resulting process determines a new stateful process - the departure process.

**Derivation:** $D(T)=\sum \text{departures in }(0,T]$.

**Unit:** Elements.

**Output file:** `core/panels/cumulative_departures_D.png`


## CFD - Cumulative Flow Diagram {#chart-04-cfd}

`with-events`

![CFD (with-events)]($document-root/articles/chart-reference/chart_reference_small/with-events/core/panels/cumulative_flow_diagram.png)

<details>
<summary>No-events version</summary>

![CFD (no-events)]($document-root/articles/chart-reference/chart_reference_small/no-events/core/panels/cumulative_flow_diagram.png)

</details>

The Cumulative Flow Diagram (CFD) is the central construction for modeling and measuring an arrival-departure process. It is not itself a metric, but a visualization that exposes the key variables governing flow.

Mechanically, it consists of the two counting processes $A(T)$ and $D(T)$ plotted together over the same sample path. However, the superposition of these processes reveals geometric relationships that impose structural constraints on the behavior of the arrival–departure process over time.

Before turning to the formal derivation, consider the intuition. If the arrival and departure curves are viewed as the bounding cumulative curves of the process, the shaded region between them represents a measurable quantity that accumulates over time. Since the horizontal axis is indexed by time, this region corresponds to a time-accumulated quantity that can be computed and reasoned about concretely. The accumulated area up to time $T$ therefore defines another process with its own state.

We call this quantity *Presence Mass* (or simply *Presence*). Formally, it is the area between the arrival and departure curves over the interval $(0,T]$. Intuitively, it measures both:

- how many elements are present in the process (the vertical separation between the curves), and  
- for how long those elements remain present (the horizontal extent over time).

Larger areas correspond to greater presence mass in the system; smaller areas correspond to less.

The interpretation of presence mass is entirely context-dependent. If arrivals represent new customers, greater presence mass may be desirable. If arrivals represent defects, smaller presence mass is preferable. Sample path flow analysis does not assign meaning to the quantities; it measures and characterizes the structure of flow through presence mass in a systematic and mathematically consistent way.

Presence mass — the area between the bounding curves — is a measurable quantity, $H(T)$, representing accumulated presence over the interval $(0,T]$. Together, the counting processes $A(\cdot)$ and $D(\cdot)$ — and equivalently the derived quantity $H(T)$ — form a sufficient state description for the classical arrival–departure flow model.

All standard flow metrics — including time averages, throughput rates, and finite-window variants of Little’s Law — can be expressed as deterministic functionals of the counting processes $A(\cdot)$ and $D(\cdot)$.

Before introducing $H(T)$ formally, we begin with an even simpler quantity: the instantaneous state of the arrival–departure process.

**Output file:** `core/panels/cumulative_flow_diagram.png`


## N(t) - Process State {#chart-05-sample-path-n}

`with-events`

![N(t) sample path (with-events)]($document-root/articles/chart-reference/chart_reference_small/with-events/core/panels/sample_path_N.png)

<details>
<summary>No-events version</summary>

![N(t) sample path (no-events)]($document-root/articles/chart-reference/chart_reference_small/no-events/core/panels/sample_path_N.png)

</details>

Builds on the CFD gap: $N(t)$ is the pointwise difference between cumulative arrivals and
cumulative departures.

**Derivation:** $N(t)=A(T)-D(T)$.

**Unit:** Elements.

**Output file:** `core/panels/sample_path_N.png`


## H(T) - Presence Mass {#chart-06-presence-mass-h}

`with-events`

![H(T) presence mass (with-events)]($document-root/articles/chart-reference/chart_reference_small/with-events/core/panels/cumulative_presence_mass_H.png)

<details>
<summary>No-events version</summary>

![H(T) presence mass (no-events)]($document-root/articles/chart-reference/chart_reference_small/no-events/core/panels/cumulative_presence_mass_H.png)

</details>

Builds on $N(t)$ by integrating it over elapsed time, producing cumulative presence mass.

**Derivation:** $H(T)=\int_0^T N(t)\,dt$.

**Unit:** Elements-Time.

**Output file:** `core/panels/cumulative_presence_mass_H.png`


## L(T) - Time-Average Presence {#chart-07-time-average-l}

`with-events`

![L(T) time average (with-events)]($document-root/articles/chart-reference/chart_reference_small/with-events/core/panels/time_average_N_L.png)

<details>
<summary>No-events version</summary>

![L(T) time average (no-events)]($document-root/articles/chart-reference/chart_reference_small/no-events/core/panels/time_average_N_L.png)

</details>

Builds on $H(T)$ by normalizing by elapsed time, yielding time-average presence.

**Derivation:** $L(T)=H(T)/T$.

**Unit:** Elements.

**Output file:** `core/panels/time_average_N_L.png`


## $\Lambda(T)$ - Arrival Rate {#chart-08-arrival-rate-lambda}

`with-events`

![Lambda(T) arrival rate (with-events)]($document-root/articles/chart-reference/chart_reference_small/with-events/core/panels/cumulative_arrival_rate_Lambda.png)

<details>
<summary>No-events version</summary>

![Lambda(T) arrival rate (no-events)]($document-root/articles/chart-reference/chart_reference_small/no-events/core/panels/cumulative_arrival_rate_Lambda.png)

</details>

Builds on cumulative arrivals by converting counts to elapsed-time-normalized arrival
rate.

**Derivation:** $\Lambda(T)=A(T)/T$.

**Unit:** Elements/Time.

**Output file:** `core/panels/cumulative_arrival_rate_Lambda.png`


## w(T) - Residence per Arrival {#chart-09-residence-w}

`with-events`

![w(T) residence per arrival (with-events)]($document-root/articles/chart-reference/chart_reference_small/with-events/core/panels/average_residence_time_w.png)

<details>
<summary>No-events version</summary>

![w(T) residence per arrival (no-events)]($document-root/articles/chart-reference/chart_reference_small/no-events/core/panels/average_residence_time_w.png)

</details>

Builds on $H(T)$ and $A(T)$ by expressing accumulated presence per arrival as average
residence per arrival.

**Derivation:** $w(T)=H(T)/A(T)$.

**Unit:** Time.

**Output file:** `core/panels/average_residence_time_w.png`


## $L(T)=\Lambda(T)\cdot w(T)$ Invariant - Arrival Invariant {#chart-10-arrival-invariant}

`with-events`

![Arrival invariant (with-events)]($document-root/articles/chart-reference/chart_reference_small/with-events/core/panels/littles_law_invariant.png)

<details>
<summary>No-events version</summary>

![Arrival invariant (no-events)]($document-root/articles/chart-reference/chart_reference_small/no-events/core/panels/littles_law_invariant.png)

</details>

Builds on Steps 7-9a by verifying the finite-window arrival-side invariant at each
observation point.

**Derivation:** $L(T)=\Lambda(T)\cdot w(T)$.

**Unit:** Elements.

**Output file:** `core/panels/littles_law_invariant.png`


## Arrival Stack - Arrival Dashboard {#chart-11-arrival-stack}

`with-events`

![Arrival stack (with-events)]($document-root/articles/chart-reference/chart_reference_small/with-events/sample_path_flow_metrics.png)

<details>
<summary>No-events version</summary>

![Arrival stack (no-events)]($document-root/articles/chart-reference/chart_reference_small/no-events/sample_path_flow_metrics.png)

</details>

Builds on Steps 5, 7, 8, and 9a by presenting the arrival-side state, average, rate, and
residence components on one aligned dashboard.

**Derivation:** $L(T)=\Lambda(T)\cdot w(T)$.

**Unit:** Mixed (Elements, Elements/Time, Time).

**Output file:** `sample_path_flow_metrics.png`


## $\Theta(T)$ - Departure Rate {#chart-12-departure-rate-theta}

`with-events`

![Theta(T) departure rate (with-events)]($document-root/articles/chart-reference/chart_reference_small/with-events/core/panels/cumulative_departure_rate_Theta.png)

<details>
<summary>No-events version</summary>

![Theta(T) departure rate (no-events)]($document-root/articles/chart-reference/chart_reference_small/no-events/core/panels/cumulative_departure_rate_Theta.png)

</details>

Builds from the departure count path by converting cumulative departures to
elapsed-time-normalized departure rate.

**Derivation:** $\Theta(T)=D(T)/T$.

**Unit:** Elements/Time.

**Output file:** `core/panels/cumulative_departure_rate_Theta.png`


## w'(T) - Residence per Departure {#chart-13-residence-w-prime}

`with-events`

![w'(T) residence per departure (with-events)]($document-root/articles/chart-reference/chart_reference_small/with-events/core/panels/average_residence_time_w_prime.png)

<details>
<summary>No-events version</summary>

![w'(T) residence per departure (no-events)]($document-root/articles/chart-reference/chart_reference_small/no-events/core/panels/average_residence_time_w_prime.png)

</details>

Builds on $H(T)$ and $D(T)$ by expressing accumulated presence per departure.

**Derivation:** $w'(T)=H(T)/D(T)$.

**Unit:** Time.

**Output file:** `core/panels/average_residence_time_w_prime.png`


## $L(T)=\Theta(T)\cdot w'(T)$ Invariant - Departure Invariant {#chart-14-departure-invariant}

`with-events`

![Departure invariant (with-events)]($document-root/articles/chart-reference/chart_reference_small/with-events/core/panels/departure_littles_law_invariant.png)

<details>
<summary>No-events version</summary>

![Departure invariant (no-events)]($document-root/articles/chart-reference/chart_reference_small/no-events/core/panels/departure_littles_law_invariant.png)

</details>

Builds on Steps 7, 11, and 12 by verifying $L(T)=\Theta(T)\cdot w'(T)$ pointwise.

**Derivation:** $L(T)=\Theta(T)\cdot w'(T)$.

**Unit:** Elements.

**Output file:** `core/panels/departure_littles_law_invariant.png`


## Departure Focused Stack - Departure Dashboard {#chart-15-departure-stack}

`with-events`

![Departure stack (with-events)]($document-root/articles/chart-reference/chart_reference_small/with-events/core/departure_flow_metrics.png)

<details>
<summary>No-events version</summary>

![Departure stack (no-events)]($document-root/articles/chart-reference/chart_reference_small/no-events/core/departure_flow_metrics.png)

</details>

Builds on Steps 5, 7, 11, and 12 by presenting the departure-side dashboard in aligned
panels.

**Derivation:** $L(T)=\Theta(T)\cdot w'(T)$.

**Unit:** Mixed (Elements, Elements/Time, Time).

**Output file:** `core/departure_flow_metrics.png`


# Convergence and Stability

| Chart | Short Name | Formula | Units |
| --- | --- | --- | --- |
| [$\Lambda(T)$-$\Theta(T)$ Rate Convergence](#chart-16-arrival-departure-rate-convergence) | Rate Convergence | $\Lambda(T)=A(T)/T$ vs $\Theta(T)=D(T)/T$ | Elem/Time |
| [Process Time Convergence](#chart-17-process-time-convergence) | Time Convergence | $w(T)=H(T)/A(T)$ vs $W^*(t)$ | Time |
| [Top-Level Convergence $L(T)$ vs $\lambda^*(t)\cdot W^*(t)$](#chart-20-sample-path-convergence) | Top-Level Convergence | $L(T)$ vs $\lambda^*(t)\cdot W^*(t)$ | Elem |




## $\Lambda(T)$-$\Theta(T)$ Rate Convergence - Rate Convergence {#chart-16-arrival-departure-rate-convergence}

`no-events`

![Arrival-departure rate convergence (no-events)]($document-root/articles/chart-reference/chart_reference_small/no-events/convergence/panels/arrival_departure_rate_convergence.png)

<details>
<summary>With-events version</summary>

![Arrival-departure rate convergence (with-events)]($document-root/articles/chart-reference/chart_reference_small/with-events/convergence/panels/arrival_departure_rate_convergence.png)

</details>

Builds from Steps 8 and 11 by directly comparing cumulative arrival and departure rate
trajectories.

**Derivation:** $\Lambda(T)=A(T)/T$ vs $\Theta(T)=D(T)/T$.

**Unit:** Elements/Time.

**Output file:** `convergence/panels/arrival_departure_rate_convergence.png`


## Process Time Convergence - Time Convergence {#chart-17-process-time-convergence}

`no-events`

![Process time convergence (no-events)]($document-root/articles/chart-reference/chart_reference_small/no-events/convergence/panels/process_time_convergence.png)

<details>
<summary>With-events version</summary>

![Process time convergence (with-events)]($document-root/articles/chart-reference/chart_reference_small/with-events/convergence/panels/process_time_convergence.png)

</details>

Builds from Step 9a by comparing finite-window residence behavior to empirical
process-time behavior.

**Derivation:** $w(T)=H(T)/A(T)$ vs $W^*(t)$.

**Unit:** Time.

**Output file:** `convergence/panels/process_time_convergence.png`


## Top-Level Convergence $L(T)$ vs $\lambda^*(t)\cdot W^*(t)$ {#chart-20-sample-path-convergence}

`no-events`

![Sample path convergence (no-events)]($document-root/articles/chart-reference/chart_reference_small/no-events/sample_path_convergence.png)

<details>
<summary>With-events version</summary>

![Sample path convergence (with-events)]($document-root/articles/chart-reference/chart_reference_small/with-events/sample_path_convergence.png)

</details>

Builds on the full chain by giving a top-level convergence diagnostic for the
finite-window Little's Law relation over the observation horizon.

**Derivation:** $L(T)$ vs $\lambda^*(t)\cdot W^*(t)$.

**Unit:** Elements.

**Output file:** `sample_path_convergence.png`
