---
title: <strong>Chart Reference</strong>
author: |
  <a href="https://github.com/presence-calculus/samplepath"><em>The Samplepath Analysis Toolkit</em></a>

document-root: ../..
header-image: $document-root/articles/chart-reference/chart_reference_small/with-events/core/panels/arrival_departure_indicator_process.png

# Configure TOC
toc: true
toc-title: Contents
toc-depth: 2
# Configure section numbers
numberSections: true
sectionsDepth: 2
# Configure figures
figPrefix: Figure
# Configure citations
citations: true
---

# Sample Path Flow Metrics

This document is a catalog of charts generated by the sample path analysis toolkit.

Given an input sample path (an arrival/departure point process, as shown above), all
computations are deterministic. Every value depends only on event order and the elapsed
time between events on that path.

Each chart shows one or more metrics and their relationships to each other and to the
underlying events on the sample path. At any point in time, each metric value can be
traced to the _specific event(s)_ that produced it. That is what enables reliable
cause-and-effect analysis of flow-metric changes.

None of these calculations are statistical summaries, and none rely on probabilistic
assumptions. To repeat: given the input sample path, every value is fully determined.

Another key feature: canonical sample path flow metrics are indexed by _events_ on the
sample path. Calendar-indexed views are derived samples of the same event-resolved
calculations.
For theory and
formal definitions behind why this matters, see [Sample Path Theory]($document-root/articles/theory).

For CLI options and output contracts, see [Command Line Reference]($document-root/articles/cli).

## Methodology
Please see the article [Sample Path Analysis vs Statistics]($document-root/articles/a-methodological-contrast) about the deeper methodological contrasts between sample path analysis and current techniques for measuring flow metrics, and why these matter
in accurate reasoning about flow.


# Notational Conventions

The charts are introduced in a canonical derivation arc starting with the sample path: each metric is
derived deterministically from prior metrics or directly from the sample path itself. The reader
is strongly encouraged to read these entries in order, as earlier entries introduce theoretical concepts
and terminology in context, and they are assumed in later ones.

## Measurements

All measurements are defined over an observation window with a _fixed_ starting point that we will denote as $0$. The underlying process may evolve stochastically or non-deterministically. At any moment, however, we work with the realized prefix of its sample path observed up to a finite horizon $T_{\max}$. It is  important to note that $T_{\max}$ denotes the _elapsed time_ since the fixed origin $0$, not an absolute timestamp.

As more events are observed, additional portions of the sample path are revealed, the observable horizon extends, and the associated measurements are recomputed on the extended prefix.

Given a realized sample path up to a fixed finite horizon, all measurements made over that prefix are deterministic. Even when the underlying process is non-deterministic, the measurements applied to the observed prefix are not.

## Notation

- Lower-case $t$ denotes *instantaneous* time.  
- Upper-case $T$ denotes a *prefix horizon* of the observation interval, i.e. an interval $(0, T]$ with $0 < T \le T_{\max}$. We adopt half-open intervals by default: the interval excludes the left endpoint and includes the right endpoint.

- For a fixed horizon $T$, the within-window time variable $t$ satisfies $0 < t \le T$.

- Functions of $t$ (such as $N(t)$) denote instantaneous sample-path values at time $t$.

- Functions of $T$ represent *cumulative quantities* or normalized quantities derived from them, computed over the interval $(0, T]$.

  For each $T$, we consider the prefix window $(0, T]$. Endpoint quantities such as $F(T)$ are values determined by the prefix up to and including time $T$, and as $T$ varies over $(0, T_{\max}]$, these endpoint values form the trajectory $T \mapsto F(T)$ which is what we display on all the charts by default.

  > This uses the standard [càdlàg](https://en.wikipedia.org/wiki/C%C3%A0dl%C3%A0g) convention for counting/jump processes: sample paths are right-continuous with left limits.

All cumulative functions are deterministic, pathwise calculations (definite integrals, discrete sums, and finite-window normalizations) applied to the realized prefix and should not be confused with statistical measures or ensemble aggregates.


## Timescales and Indexes

All charts use continuous time on the x-axis.

- In event-indexed views, points are evaluated at exact event timestamps from the
  input sample path.
- In calendar-indexed views, points are evaluated at calendar boundaries, but values
  are still computed from the same underlying event-resolved pathwise calculations.

Internally, durations are measured in seconds and then durations and rates are converted automatically
to a consistent scale suitable for human-friendly display. This automatic scaling of units happens _on the y-axis only_;
the x-axis remains continuous time.

Calendar indexing is simply a coarser *sampling grid* over _metrics_ computed from the
event-resolved sample path at the input granularity. We do not pre-aggregate events into calendar buckets and then
compute flow metrics from those aggregates, like other flow metrics tools (incorrectly) do.

All core charts shown in this document should be assumed to be event-indexed by default, unless explicitly specified otherwise.

Although calendar dates may appear on the time axis as reference labels, the underlying x-axis values correspond to exact event timestamps. These timestamps are not constrained to fall on calendar reporting boundaries and may occur at arbitrary points in continuous time.

## Event display

Event indexing is a key differentiator of sample path analysis, so charts are shown with event-resolved overlays by default: each plotted point is tied to an arrival or departure event. This makes the event-level impact on each flow-metric trajectory explicit. Arrival points are colored purple, departure points green, and each point includes a drop line to its x-axis timestamp. This detail is essential for deterministic cause-and-effect analysis.

Each chart also has a `--no-events` version with overlays removed. These views are useful for higher-level gestalt analysis of trajectories across views, especially in dashboards. When reviewing these charts, I recommend you take a look at both views to build intuition.



# The Presence Invariant

The Presence Invariant is the finite-horizon form of Little’s Law.

$$
\begin{aligned}
L(T) &= \Lambda(T)\,w(T) = \Theta(T)\,w'(T)
\end{aligned}
$$

For the full derivation context and interpretation, refer to [Sample Path Theory: Presence Invariant]($document-root/articles/theory#presence-invariant).

The quantities in this law are the finite horizon equivalents of the quantities in the familiar steady state view of Little's Law,
But unlike the steady state version the presence invariant _holds unconditionally at all times_.

This section shows the step-by-step derivation of each quantity in the invariant and visualizes how the values of each metric at every point in time are derived from the sample path. The charts are presented in a canonical order starting with the input sample path. Each chart depends on one or more metrics in an earlier chart. All calculations are deterministic.

Review the theory doc and use it as a cross-reference when reviewing the charts below. The ideas here are relatively straightforward if you spend a little bit of time carefully reading, understanding and reviewing what each chart means and the sequence of derivations.



| Chart                                              | Name                             | Formula                                | Units |
|----------------------------------------------------|----------------------------------|----------------------------------------| --- |
| [Point Process](#chart-01-point-process)           | Sample Path                      | Input event stream                     | N/A |
| [A(T)](#chart-02-arrivals-a)                       | Cumulative Arrivals              | $A(T)=\sum \text{arrivals in }(0,T]$   | Elem |
| [D(T)](#chart-03-departures-d)                     | Cumulative Departures            | $D(T)=\sum \text{departures in }(0,T]$ | Elem |
| [CFD](#chart-04-cfd)                               | Cumulative Flow Diagram          |                                        | N/A |
| [N(t)](#chart-05-sample-path-n)                    | Instantaneous Process State      | $N(t)=A(T)-D(T)$                       | Elem |
| [H(T)](#chart-06-presence-mass-h)                  | Cumulative Presence Mass         | $H(T)=\int_0^T N(t)\,dt$               | Elem-Time |
| [L(T)](#chart-07-time-average-l)                   | (Time) Average State             | $L(T)=H(T)/T$                          | Elem |
| [$\Lambda(T)$](#chart-08-arrival-rate-lambda)      | Arrival Rate                     | $\Lambda(T)=A(T)/T$                    | Elem/Time |
| [w(T)](#chart-09-residence-w)                      | Residence Time per Arrival       | $w(T)=H(T)/A(T)$                       | Time |
| [Arrival Invariant](#chart-10-arrival-invariant)   | Arrivals Focused Invariant       | $L(T)=\Lambda(T)\cdot w(T)$            | Elem |
| [Arrival Stack](#chart-11-arrival-stack)           | Arrival Focused Flow Dashboard   | $N(t), L(T), \Lambda(T), w(T)$         | N/A |
| [$\Theta(T)$](#chart-12-departure-rate-theta)      | Departure Rate                   | $\Theta(T)=D(T)/T$                     | Elem/Time |
| [w'(T)](#chart-13-residence-w-prime)               | Residence Time per Departure     | $w'(T)=H(T)/D(T)$                      | Time |
| [Departure Invariant](#chart-14-departure-invariant) | Departures Focused Invariant     | $N(t), L(T), \Theta(T), w'(T)$         | Elem |
| [Departure Stack](#chart-15-departure-stack)       | Departure Focused Flow Dashboard | $L(T)=\Theta(T)\cdot w'(T)$            | N/A |



## Point Process - Event Stream {#chart-01-point-process}

`with-events`

![Point Process (with-events)]($document-root/articles/chart-reference/chart_reference_small/with-events/core/panels/arrival_departure_indicator_process.png)

<details>
<summary>No-events version</summary>

![Point Process (no-events)]($document-root/articles/chart-reference/chart_reference_small/no-events/core/panels/arrival_departure_indicator_process.png)

</details>

This is the sample path: the input to sample path analysis. It is the observed behavior of some operational process modeled as a sequence of arrival and departure events on a timeline.

It is represented as a timestamped event sequence with an indicator (a mark) at each timestamp. Here the mark indicates whether an event is an arrival or a departure. For core Presence Invariant calculations, this is sufficient.

The sample path encodes _non-deterministic process behavior_ along two dimensions: the discrete sequence of event types (including the ordering of arrivals and departures), and the continuous inter-event durations.

A useful mental model for the observable behavior of the underlying process is a simple coin flip observed over time. Each flip determines whether the next event is an arrival or a departure. In an arrival-departure process, however, we care about both dimensions of what is observed: the event outcome and the _elapsed time_ to the next event.

We call this class of non-deterministic models _flow processes_. The specific case where event type is binary (arrival or departure) is a _binary_ flow process. The same machinery extends naturally to a broader class of non-deterministic marked point processes, but this library currently implements only the binary case.

Note: An `id` mark that pairs arrivals with departures is _optional_ for the core invariant metrics, but _required_ for item-level sojourn-time measurements. This only becomes relevant when discussing convergence, stability and the familiar steady-state version of Little's Law.

**Output file:** `core/panels/arrival_departure_indicator_process.png`

## A(T) - Cumulative Arrivals {#chart-02-arrivals-a}

`with-events`

![A(T) cumulative arrivals (with-events)]($document-root/articles/chart-reference/chart_reference_small/with-events/core/panels/cumulative_arrivals_A.png)

<details>
<summary>No-events version</summary>

![A(T) cumulative arrivals (no-events)]($document-root/articles/chart-reference/chart_reference_small/no-events/core/panels/cumulative_arrivals_A.png)

</details>

**Derivation:** $A(T)=\sum \text{arrivals in }(0,T]$.

**Unit:** Elements.

The simplest measurement on the sample path is a _cumulative count_. In particular, for a moment $T$ in the observation window $(0, T_{\max}]$, we count the arrivals observed in the prefix interval $(0, T]$.

Formally, following our convention, we define

$$
A(T)=\#\{\,i:\ 0 < a_i \le T\,\}
$$

where $a_i$ is an arrival timestamp and $\#$ denotes set cardinality. In most contexts however, we will use the simpler but less precise notation shown in the derivation above.

While this appears to be a simple metric, several important structural properties are worth highlighting, and they motivate conceptual distinctions that fundamentally separate sample path analysis from traditional statistical approaches to measuring flow.

### Events define measurements

The key observation is that the trajectory of $A(T)$ is completely determined by discrete arrival events.

- $A(T)$ is defined for all $T \in (0, T_{\max}]$, so it is a function of time.
- It is a right-continuous step function that _increases by one at each arrival timestamp_ and _is constant between arrival events_.
- Given the ordered arrival timestamps, the entire function is uniquely determined for all $T$.

The reader is urged to verify that these properties hold for the examples we have shown.

### Measurements map to state

This stepwise structure naturally leads to the notion of process _state_.

The value of $A(T)$ at a given time $T$ can be viewed as the state of the counting process at that moment. As $T$ increases, this state evolves over time. State transitions occur only at arrival timestamps, where $A(T)$ increases by one; between arrivals, the state remains constant.

$A(T)$ itself models a single dimensional state - a cumulative count of arrivals. As we will soon see, all flow metrics can be viewed as processes, that model higher dimensional states arising from the interactions
of these lower dimensional states.


### State and time define processes

In stochastic process theory, a _process_ is defined as a mapping from an index set to a state space. The counting process $A(T)$ is a simple example: it maps continuous time $T$ to the state space $\mathbb{N}$ of natural numbers.

The same arrival structure can also be indexed by event order, yielding the embedded discrete-time sequence $\{A(a_i)\}$ evaluated at arrival times. These two parameterizations — time-indexed and event-indexed — describe the same underlying arrival process.

>In El-Taha and Stidham [@eltaha1999], such processes are called _processes with an embedded point process_. We will use the more informal term _event-indexed_ process throughout this document, with the assumption that such processes can be parametrized by event time stamps or continuous time.



Another crucial observation is that these processes are deterministic _functionals_ of the realized sample path. Each metric is obtained by applying a well-defined mapping, or a sequence of mappings, to the underlying sample path. This allows us to reason _deterministically_ about how a change in the underlying events propagates through all derived processes over time, and to connect every quantity back to the original events via the event index.

Think of these relationships like a series of cells updating on a spreadsheet. The next value of the metric depends upon the previous value and the _next event_ on the sample path. This latter choice is non-deterministic. Everything after that is deterministically computed once that choice is resolved. Verify that this holds for $A(T)$.

Similar properties hold for _every_ metric we compute. Our charts and exports emphasize the _event-indexed_ nature of these functions over the sample path. This stands in stark contrast to statistical measures, where we typically speak only of correlations between aggregates rather than deterministic dependence.


**Output file:** `core/panels/cumulative_arrivals_A.png`


## D(T) - Cumulative Departures {#chart-03-departures-d}

`with-events`

![D(T) cumulative departures (with-events)]($document-root/articles/chart-reference/chart_reference_small/with-events/core/panels/cumulative_departures_D.png)

<details>
<summary>No-events version</summary>

![D(T) cumulative departures (no-events)]($document-root/articles/chart-reference/chart_reference_small/no-events/core/panels/cumulative_departures_D.png)

</details>

This is the identical construction as $A(T)$ but for departure marks. Like $A(T)$, $D(T)$ is a right-continuous step function that increases by one at each departure timestamp and is constant between departures.

The resulting process determines a new stateful process - the departure process.

**Derivation:** $D(T)=\sum \text{departures in }(0,T]$.

**Unit:** Elements.

**Output file:** `core/panels/cumulative_departures_D.png`


## CFD - Cumulative Flow Diagram {#chart-04-cfd}

`with-events`

![CFD (with-events)]($document-root/articles/chart-reference/chart_reference_small/with-events/core/panels/cumulative_flow_diagram.png)

<details>
<summary>No-events version</summary>

![CFD (no-events)]($document-root/articles/chart-reference/chart_reference_small/no-events/core/panels/cumulative_flow_diagram.png)

</details>

The Cumulative Flow Diagram (CFD) is the central construction for modeling and measuring an arrival-departure process. It is not itself a metric, but a visualization that exposes the key variables governing flow.

Mechanically, it consists of the two counting processes $A(T)$ and $D(T)$ plotted together over the same sample path. However, the superposition of these processes reveals geometric relationships that impose structural constraints on the behavior of the arrival–departure process over time.

Before turning to the formal derivation, consider the intuition. If the arrival and departure curves are viewed as the bounding cumulative curves of the process, the shaded region between them represents a measurable quantity that accumulates over time. Since the horizontal axis is indexed by time, this region corresponds to a time-accumulated quantity that can be computed and reasoned about concretely. The accumulated area up to time $T$ therefore defines another process with its own state.

We call this quantity *Presence Mass* (or simply *Presence*). Formally, it is the area between the arrival and departure curves over the interval $(0,T]$. Intuitively, it measures both:

- how many elements are present in the process (the vertical separation between the curves), and  
- for how long those elements remain present (the horizontal extent over time).

Larger areas correspond to greater presence mass in the system; smaller areas correspond to less.

The interpretation of presence mass is entirely context-dependent. If arrivals represent new customers, greater presence mass may be desirable. If arrivals represent defects, smaller presence mass is preferable. Sample path flow analysis does not assign meaning to the quantities; it measures and characterizes the structure of flow through presence mass in a systematic and mathematically consistent way.

Presence mass — the area between the bounding curves — is a measurable quantity, $H(T)$, representing accumulated presence over the interval $(0,T]$. Together, the counting processes $A(\cdot)$ and $D(\cdot)$ — and equivalently the derived quantity $H(T)$ — form a sufficient state description for the classical arrival–departure flow model.

All standard flow metrics — including time averages, throughput rates, and finite-window variants of Little’s Law — can be expressed as deterministic functionals of the counting processes $A(\cdot)$ and $D(\cdot)$.

Before introducing $H(T)$ formally, we begin with an even simpler quantity: the instantaneous state of the arrival–departure process.

**Output file:** `core/panels/cumulative_flow_diagram.png`


## N(t) - Process State {#chart-05-sample-path-n}

`with-events`

![N(t) sample path (with-events)]($document-root/articles/chart-reference/chart_reference_small/with-events/core/panels/sample_path_N.png)

<details>
<summary>No-events version</summary>

![N(t) sample path (no-events)]($document-root/articles/chart-reference/chart_reference_small/no-events/core/panels/sample_path_N.png)

</details>

**Derivation:** $N(t)=A(T)-D(T)$.

**Unit:** Elements.

The first thing the CFD allows us to do is determine how many elements are present in the process (have arrived but not departed) at any instant of time. On the CFD, this is just the vertical distance between the $A(T)$ and $D(T)$ lines.

We may define this as a new process
$$ N(t) = A(T) - D(T)$$

> Note: Here $A(T)$ and $D(T)$ are cumulative functions on $(0,T]$, and we set $t:=T$ at the endpoint; their difference at each $T$ is the instantaneous state $N(t)$.

$N(t)$ is the instantaneous number of elements present in the arrival-departure process. This is the quantity we commonly call WIP in software contexts.

The plot of $N(t)$ against the event timeline is called the _process state_ chart because, viewed as a process, it is interpretable as an instantaneous state variable of the arrival-departure process.

- An arrival event causes it to increase by 1
- A departure event causes it to decrease by 1
- Like $A(T)$ and $D(T)$, $N(t)$ changes only at event boundaries, remaining constant in between.

> In summary, the arrival and departure events change the state of the arrival-departure process with $N(t)$ capturing the state
as the net _effect_ of cumulative arrivals and departures.

One thing that may not be immediately obvious, but is true nevertheless, is that the shared grey area under the $N(t)$ curve is exactly the same area between the arrival and departure lines in the CFD. The differences are mainly due to scaling and display, but the shaded area represents the same quantity, the Presence Mass we saw in the CFD.

Generally speaking, the process state plot gives us a simpler and more operationally useful way of examining and reasoning about presence, and so for the most part, we will rely on $N(t)$ as the core flow metric upon which we build the rest of the metrics in the Presence Invariant.


**Output file:** `core/panels/sample_path_N.png`


## H(T) - Presence Mass {#chart-06-presence-mass-h}

`with-events`

![H(T) presence mass (with-events)]($document-root/articles/chart-reference/chart_reference_small/with-events/core/panels/cumulative_presence_mass_H.png)

<details>
<summary>No-events version</summary>

![H(T) presence mass (no-events)]($document-root/articles/chart-reference/chart_reference_small/no-events/core/panels/cumulative_presence_mass_H.png)

</details>

**Derivation:** $H(T)=\int_0^T N(t)\,dt$.

**Unit:** Elements-Time.

In addition to the number of elements present at any instant, the CFD also visualizes how long they were present. To make this notion precise, examine the $N(t)$ chart carefully. Since $N(t)$ changes value only at event boundaries and remains constant between them, each interval between changes can be interpreted as the time the arrival–departure process remains in a given state.

Each rectangular segment under the $N(t)$ path represents a time-weighted accumulation of presence mass in that state. This is the incremental presence mass generated while the process remained at that cardinality.

The cumulative presence mass added over an interval $(0,T]$ is the sum of these rectangles. More generally, it is expressed as the definite integral of $N(t)$, which also captures any partial accumulation between events:

$$
H(T) = \int_0^T N(t)\,dt
$$

> Note that presence mass lives in a product space of elements and time, so the units of $H(T)$ are element-time.

Now when $H(T)$ is plotted against time, it inherits structural properties from $N(t)$:

- Events change the trajectory of $H(T)$.
- Between events, the path increases linearly.
- The slope of the path between events is $N(t)$, the instantaneous state of the process over that interval.
- Arrival events increase the slope; departures decrease the slope.
- The path is flat when $N(t)=0$.

The reader is encouraged to compare the charts of $N(t)$ and $H(T)$ and confirm that this structure holds exactly.
Like its inputs, $H(T)$ is a deterministic functional of the realized sample path of $N(t)$. Once the trajectory of $N(t)$ over $(0,T]$ is known, the value of $H(T)$ is uniquely determined: $H(T)$ is obtained purely by integrating the observed path.


> $H(T)$ encodes a simple rule: higher cardinality process states accumulate presence at a faster rate.

Whether this is desirable depends on context. In a development setting, where $N(t)$ represents WIP, presence corresponds to delay exposure, and higher $N(t)$ implies delay is accumulating more rapidly. In a customer service context, presence may represent active customer engagement, implying faster growth in retained customers. The mathematics is agnostic to interpretation; only the objective changes.

> This makes $H(T)$ the minimal integrated variable that captures the history of process states over $(0,T]$. While $N(t)$ captures the instantaneous state, $H(T)$ captures the accumulated presence generated by that state over time. In this sense, $H(T)$ compresses the entire past evolution of $N(t)$ into a single scalar quantity that evolves over time.






**Output file:** `core/panels/cumulative_presence_mass_H.png`


## L(T) - Time-Average of Presence {#chart-07-time-average-l}

`with-events`

![L(T) time average (with-events)]($document-root/articles/chart-reference/chart_reference_small/with-events/core/panels/time_average_N_L.png)

<details>
<summary>No-events version</summary>

![L(T) time average (no-events)]($document-root/articles/chart-reference/chart_reference_small/no-events/core/panels/time_average_N_L.png)

</details>

**Derivation:** $L(T)=H(T)/T$.

**Unit:** Elements.

We now have the core machinery in place to derive the quantities in the Presence Invariant

$$
L(T) = \Lambda(T)\, w(T).
$$

First we examine the left-hand side of the invariant, $L(T)$. This is simply cumulative presence $H(T)$ normalized over the observation interval $T$:

$$
L(T) = \frac{H(T)}{T}
= \frac{1}{T} \int_0^T N(t)\,dt.
$$

Before jumping into the details, the reader is urged to carefully review the charts of $N(t)$, $H(T)$, and $L(T)$ and get an intuition for what the relationship
of each of these charts to the underlying events in the point process might be.

We call $L(T)$ the *time average of presence*. But what does that mean?


### $L(T)$ as a moving average of $N(t)$

Recall that $H(T)$ is cumulative presence mass over $(0,T]$, obtained by integrating $N(t)$ over time. It is therefore a time-weighted accumulation of the instantaneous process state.

Dividing by $T$ yields the time average of $N(t)$ over $(0,T]$. Thus $L(T)$ can be interpreted directly in terms of $N(t)$, which is a more tangible quantity.

The straightforward interpretation is that $L(T)$ is a long-horizon *moving average* of $N(t)$: each additional moment the process spends in state $N(t)$ contributes an increment of time to the numerator, while the denominator grows linearly as the observation window expands.

This gives $L(T)$ several important structural properties:

- It does not jump when arrivals or departures occur: the integration step in $H(T)$ removes discontinuities, and normalization in $L(T)$ causes the *influence* of any individual event to be time-weighted.

- It adjusts gradually: as $T$ grows, each new increment of time carries weight proportional to $1/T$.

- The effect of any *finite* disturbance fades over time, _unless_ the underlying state process sustains linear (or faster) growth in $N(t)$.

> For this reason, $L(T)$ serves as a diagnostic of persistent structural changes in the state process.
> Transient fluctuations are progressively washed out. What remains visible in $L(T)$ as $T$ grows are only those components of $N(t)$ that persist.

If $L(T)$ rises, falls, or stabilizes, it does so because the underlying state process exhibits sustained imbalance, sustained correction, or sustained equilibrium.
We will return to this when we discuss convergence, equilibrium, and stability.

Also see [Structural vs Transient Effects on a Sample Path](#structural-vs-transient-effects-on-a-sample-path) for the relationship between $L(T)$ and the common-cause/special-cause distinction from Statistical Process Control.


### How $L(T)$ changes

In [Derivative of $L(T)$](#derivative-of-lt) we show that the first derivative of $L(T)$ (the rate at which it changes over time) is given by

$$
\frac{dL}{dT}
=
\frac{N(t) - L(T)}{T}.
$$
Here $N(t)$ should be interpreted as the instantaneous state at the endpoint of the interval $(0,T]$. So this compares the moving average of $N(t)$ over
$(0,T]$ to the endpoint value $N(t)$.

This expression is a standard result for the _sensitivity of a cumulative moving average_ and it makes the relationship between $N(t)$ and $L(T)$ explicit:

- If $N(t) > L(T)$, then $\frac{dL}{dT} > 0$ and $L(T)$ increases.
- If $N(t) < L(T)$, then $\frac{dL}{dT} < 0$ and $L(T)$ decreases.
- The rate of adjustment is proportional to $1/T$.

Thus $L(T)$ tracks $N(t)$ with diminishing sensitivity over time: over longer horizons, $L(T)$ adjusts more slowly to changes in the instantaneous state.


### Symmetry of Arrivals and Departures

Arrivals and departures affect $L(T)$ only through their impact on $N(t)$.

- An arrival increases $N(t)$ by one.
- A departure decreases $N(t)$ by one.

Because the evolution of $L(T)$ depends only on the difference $N(t) - L(T)$, arrivals and departures enter symmetrically at the level of the state variable. Each event shifts $N(t)$ up or down, and $L(T)$ responds according to the same averaging rule.

> Unlike $H(T)$, where arrivals and departures have visibly different geometric effects on slope, at the level of $L(T)$ their influence is structurally symmetric: both modify the instantaneous state, and the running average _adjusts toward that state_.



### $L(T)$ as an average accumulation rate of presence

Since $H(T)$ is the time-weighted accumulation of instantaneous states over $(0,T]$, it follows that

$$
L(T) = \frac{H(T)}{T}
$$

is the average value of $N(t)$ over that interval. Because

$$
\frac{dH}{dT} = N(t),
$$

$N(t)$ represents the instantaneous rate at which presence mass accumulates. Accordingly, $L(T)$ is the *average rate of accumulation* of presence mass over $(0,T]$.

Importantly, this is an arithmetic time average taken along a realized sample path. It is not a distributional quantity and does not rely on stationarity or probabilistic assumptions.

Depending on how presence is interpreted, this quantity expresses a core operational metric. If the objective is to accumulate presence mass, a higher value of $L(T)$ implies a higher average accumulation rate. If the objective is to minimize accumulation (for example, reducing delay exposure in a delivery process), then lower values imply that delays are accumulating at a lower rate.

> In summary, $L(T)$ serves as a primary operational metric for an arrival–departure process as a whole. However, it cannot always be interpreted in isolation. This is where the quantities on the right-hand side of the Presence Invariant become essential.



**Output file:** `core/panels/time_average_N_L.png`


## $\Lambda(T)$ - Arrival Rate {#chart-08-arrival-rate-lambda}

`with-events`

![Lambda(T) arrival rate (with-events)]($document-root/articles/chart-reference/chart_reference_small/with-events/core/panels/cumulative_arrival_rate_Lambda.png)

<details>
<summary>No-events version</summary>

![Lambda(T) arrival rate (no-events)]($document-root/articles/chart-reference/chart_reference_small/no-events/core/panels/cumulative_arrival_rate_Lambda.png)

</details>

Builds on cumulative arrivals by converting counts to elapsed-time-normalized arrival
rate.

**Derivation:** $\Lambda(T)=A(T)/T$.

**Unit:** Elements/Time.

**Output file:** `core/panels/cumulative_arrival_rate_Lambda.png`


## w(T) - Residence per Arrival {#chart-09-residence-w}

`with-events`

![w(T) residence per arrival (with-events)]($document-root/articles/chart-reference/chart_reference_small/with-events/core/panels/average_residence_time_w.png)

<details>
<summary>No-events version</summary>

![w(T) residence per arrival (no-events)]($document-root/articles/chart-reference/chart_reference_small/no-events/core/panels/average_residence_time_w.png)

</details>

Builds on $H(T)$ and $A(T)$ by expressing accumulated presence per arrival as average
residence per arrival.

**Derivation:** $w(T)=H(T)/A(T)$.

**Unit:** Time.

**Output file:** `core/panels/average_residence_time_w.png`


## $L(T)=\Lambda(T)\cdot w(T)$ Invariant - Arrival Invariant {#chart-10-arrival-invariant}

`with-events`

![Arrival invariant (with-events)]($document-root/articles/chart-reference/chart_reference_small/with-events/core/panels/littles_law_invariant.png)

<details>
<summary>No-events version</summary>

![Arrival invariant (no-events)]($document-root/articles/chart-reference/chart_reference_small/no-events/core/panels/littles_law_invariant.png)

</details>

Builds on Steps 7-9a by verifying the finite-window arrival-side invariant at each
observation point.

**Derivation:** $L(T)=\Lambda(T)\cdot w(T)$.

**Unit:** Elements.

**Output file:** `core/panels/littles_law_invariant.png`


## Arrival Stack - Arrival Dashboard {#chart-11-arrival-stack}

`with-events`

![Arrival stack (with-events)]($document-root/articles/chart-reference/chart_reference_small/with-events/sample_path_flow_metrics.png)

<details>
<summary>No-events version</summary>

![Arrival stack (no-events)]($document-root/articles/chart-reference/chart_reference_small/no-events/sample_path_flow_metrics.png)

</details>

Builds on Steps 5, 7, 8, and 9a by presenting the arrival-side state, average, rate, and
residence components on one aligned dashboard.

**Derivation:** $L(T)=\Lambda(T)\cdot w(T)$.

**Unit:** Mixed (Elements, Elements/Time, Time).

**Output file:** `sample_path_flow_metrics.png`


## $\Theta(T)$ - Departure Rate {#chart-12-departure-rate-theta}

`with-events`

![Theta(T) departure rate (with-events)]($document-root/articles/chart-reference/chart_reference_small/with-events/core/panels/cumulative_departure_rate_Theta.png)

<details>
<summary>No-events version</summary>

![Theta(T) departure rate (no-events)]($document-root/articles/chart-reference/chart_reference_small/no-events/core/panels/cumulative_departure_rate_Theta.png)

</details>

Builds from the departure count path by converting cumulative departures to
elapsed-time-normalized departure rate.

**Derivation:** $\Theta(T)=D(T)/T$.

**Unit:** Elements/Time.

**Output file:** `core/panels/cumulative_departure_rate_Theta.png`


## w'(T) - Residence per Departure {#chart-13-residence-w-prime}

`with-events`

![w'(T) residence per departure (with-events)]($document-root/articles/chart-reference/chart_reference_small/with-events/core/panels/average_residence_time_w_prime.png)

<details>
<summary>No-events version</summary>

![w'(T) residence per departure (no-events)]($document-root/articles/chart-reference/chart_reference_small/no-events/core/panels/average_residence_time_w_prime.png)

</details>

Builds on $H(T)$ and $D(T)$ by expressing accumulated presence per departure.

**Derivation:** $w'(T)=H(T)/D(T)$.

**Unit:** Time.

**Output file:** `core/panels/average_residence_time_w_prime.png`


## $L(T)=\Theta(T)\cdot w'(T)$ Invariant - Departure Invariant {#chart-14-departure-invariant}

`with-events`

![Departure invariant (with-events)]($document-root/articles/chart-reference/chart_reference_small/with-events/core/panels/departure_littles_law_invariant.png)

<details>
<summary>No-events version</summary>

![Departure invariant (no-events)]($document-root/articles/chart-reference/chart_reference_small/no-events/core/panels/departure_littles_law_invariant.png)

</details>

Builds on Steps 7, 11, and 12 by verifying $L(T)=\Theta(T)\cdot w'(T)$ pointwise.

**Derivation:** $L(T)=\Theta(T)\cdot w'(T)$.

**Unit:** Elements.

**Output file:** `core/panels/departure_littles_law_invariant.png`


## Departure Focused Stack - Departure Dashboard {#chart-15-departure-stack}

`with-events`

![Departure stack (with-events)]($document-root/articles/chart-reference/chart_reference_small/with-events/core/departure_flow_metrics.png)

<details>
<summary>No-events version</summary>

![Departure stack (no-events)]($document-root/articles/chart-reference/chart_reference_small/no-events/core/departure_flow_metrics.png)

</details>

Builds on Steps 5, 7, 11, and 12 by presenting the departure-side dashboard in aligned
panels.

**Derivation:** $L(T)=\Theta(T)\cdot w'(T)$.

**Unit:** Mixed (Elements, Elements/Time, Time).

**Output file:** `core/departure_flow_metrics.png`


# Convergence and Stability

| Chart | Short Name | Formula | Units |
| --- | --- | --- | --- |
| [$\Lambda(T)$-$\Theta(T)$ Rate Convergence](#chart-16-arrival-departure-rate-convergence) | Rate Convergence | $\Lambda(T)=A(T)/T$ vs $\Theta(T)=D(T)/T$ | Elem/Time |
| [Process Time Convergence](#chart-17-process-time-convergence) | Time Convergence | $w(T)=H(T)/A(T)$ vs $W^*(t)$ | Time |
| [Top-Level Convergence $L(T)$ vs $\lambda^*(t)\cdot W^*(t)$](#chart-20-sample-path-convergence) | Top-Level Convergence | $L(T)$ vs $\lambda^*(t)\cdot W^*(t)$ | Elem |




## $\Lambda(T)$-$\Theta(T)$ Rate Convergence - Rate Convergence {#chart-16-arrival-departure-rate-convergence}

`no-events`

![Arrival-departure rate convergence (no-events)]($document-root/articles/chart-reference/chart_reference_small/no-events/convergence/panels/arrival_departure_rate_convergence.png)

<details>
<summary>With-events version</summary>

![Arrival-departure rate convergence (with-events)]($document-root/articles/chart-reference/chart_reference_small/with-events/convergence/panels/arrival_departure_rate_convergence.png)

</details>

Builds from Steps 8 and 11 by directly comparing cumulative arrival and departure rate
trajectories.

**Derivation:** $\Lambda(T)=A(T)/T$ vs $\Theta(T)=D(T)/T$.

**Unit:** Elements/Time.

**Output file:** `convergence/panels/arrival_departure_rate_convergence.png`


## Process Time Convergence - Time Convergence {#chart-17-process-time-convergence}

`no-events`

![Process time convergence (no-events)]($document-root/articles/chart-reference/chart_reference_small/no-events/convergence/panels/process_time_convergence.png)

<details>
<summary>With-events version</summary>

![Process time convergence (with-events)]($document-root/articles/chart-reference/chart_reference_small/with-events/convergence/panels/process_time_convergence.png)

</details>

Builds from Step 9a by comparing finite-window residence behavior to empirical
process-time behavior.

**Derivation:** $w(T)=H(T)/A(T)$ vs $W^*(t)$.

**Unit:** Time.

**Output file:** `convergence/panels/process_time_convergence.png`


## Top-Level Convergence $L(T)$ vs $\lambda^*(t)\cdot W^*(t)$ {#chart-20-sample-path-convergence}

`no-events`

![Sample path convergence (no-events)]($document-root/articles/chart-reference/chart_reference_small/no-events/sample_path_convergence.png)

<details>
<summary>With-events version</summary>

![Sample path convergence (with-events)]($document-root/articles/chart-reference/chart_reference_small/with-events/sample_path_convergence.png)

</details>

Builds on the full chain by giving a top-level convergence diagnostic for the
finite-window Little's Law relation over the observation horizon.

**Derivation:** $L(T)$ vs $\lambda^*(t)\cdot W^*(t)$.

**Unit:** Elements.

**Output file:** `sample_path_convergence.png`


# Appendices

## Derivative of $L(T)$

The derivation of
$$
\frac{dL}{dT}
=
\frac{N(t) - L(T)}{T}.
$$
Here $N(t)$ should be interpreted as the instantaneous state at the endpoint of the interval $(0,T]$.

Start with

$$
L(T) = \frac{H(T)}{T}.
$$

Think of this as a quotient of two functions of $T$:

- numerator: $H(T)$  
- denominator: $T$

Differentiate using the quotient rule:

$$
\frac{d}{dT}\left(\frac{H(T)}{T}\right)
=
\frac{T \cdot \frac{dH}{dT} - H(T) \cdot \frac{d}{dT}(T)}{T^2}.
$$

Now simplify the pieces:

- $\frac{d}{dT}(T) = 1$  
- $\frac{dH}{dT} = N(t)$ (because $H(T) = \int_0^T N(t)\,dt$)

Substitute both:

$$
\frac{dL}{dT}
=
\frac{T \cdot N(t) - H(T) \cdot 1}{T^2}
=
\frac{T N(t) - H(T)}{T^2}.
$$

Now rewrite $H(T)$ in terms of $L(T)$:

Since $L(T) = \frac{H(T)}{T}$, we have $H(T) = T L(T)$.

Substitute:

$$
\frac{dL}{dT}
=
\frac{T N(t) - T L(T)}{T^2}
=
\frac{T\big(N(t) - L(T)\big)}{T^2}.
$$

Cancel one factor of $T$:

$$
\frac{dL}{dT}
=
\frac{N(t) - L(T)}{T}.
$$


## Structural vs Transient Effects on a Sample Path

The behavior of $L(T)$ provides a deterministic sample path analogue of the common-cause / special-cause distinction in SPC, but without requiring any probabilistic or statistical assumptions.

Because $L(T)$ is defined directly from the realized sample path — via integration and normalization — it distinguishes between:

- **Finite, localized disturbances**, whose influence decays as $1/T$, and  
- **Sustained structural effects**, whose influence persists because they continuously contribute presence mass over time.

This distinction does not rely on stationarity, ergodicity, or the existence of stable distributions. It operates directly on the observed prefix of the process and remains valid even in transient, unstable, or regime-shifting systems.

In fact, this sample-path diagnostic is most useful precisely in those regimes where statistical process control is not yet justified — before averages stabilize and distributional assumptions become defensible.

Once the process exhibits sustained stability and time averages converge, traditional SPC methods can be layered on top. But $L(T)$ provides structural insight prior to — and independent of — those probabilistic assumptions.


# References
